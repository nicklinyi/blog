[{"categories":null,"contents":"地震学软件  AxiSEM3D DENISE Madagascar MinesJTK PyCurvelab SeismicJulia Seismic Unix SEPlib SPECFEM2D SPECFEM3D TOOLBOX-OPTIMIZATION TOY2DAC  工具库  OpenCV  常用软件  常用软件  数学库  METIS MUMPS SCOTCH  系统  Debian Stretch manjaro WSL  高性能计算  CUDA MPICH  机器学习  TensorFlow Keras caffe  ","permalink":"https://blog.nickwhyy.top/collection/","tags":null,"title":"安装"},{"categories":null,"contents":"正演模拟 谱元法  SPECFEM1D - Spectral element seismic modelling code in 1D media SPECFEM2D - Spectral element seismic modelling code in 2D Cartesian Coordinates SPECFEM3D - Spectral element seismic modelling code in 3D Cartesian Coordinates SPECFEM3D_GLOBE - Spectral element seismic modelling code in 3D Spherical Coordinates  有限差分  Seismic 2D/3D modelling FD codes SOFI from　KIT Seismic CPML 2D/3D FD modelling codes for visco- and　poroelastic media by D. Komatitsch and R.　Martin  有限元  NEXD - 2D/3D seismic nodal DG-FEM codes by Lasse Lambrecht Montjoie - FE-Codes from Inria  全波形反演  TOY2DAC - 2D FDFD acoustic FWI code by R. Brossier and L.　Métivier ASKI - modularized program suite for sensitivity analysis and　FWI SimpleFWI - small FDFD Matlab FWI code by T. van　Leeuwen JuliaInvFWI - small FDFD JULIA FWI　code SES3D - Spectral element (visco)elastic Modelling and FWI code from ETH-Zürich Seismic 2D FWI codes IFOS from KIT  勘探地震学相关软件  Seismic Unix Madagascar SEPlib CREWES SeismiGraphix Read and view SEG-Y etc. SeismicJulia OpendTect 比较各种不同的地震学软件  研究小组  CWP SEP SEISCOPE  ","permalink":"https://blog.nickwhyy.top/links/","tags":null,"title":"链接"},{"categories":null,"contents":"博客起源 长久以来各种不良的科研习惯导致知识的分类比较混乱，很多东西用完没有及时整理，等到下次再用的时候， 发现又得重头再熟悉一遍，严重地降低了学习效率。基于此，并受 Seisman 博客启发，由此想到记录整理 一些大家都用得着的知识，公布在网上。方便自己也许也会方便大家。\n学术交流 关于与博客内容相关问题，可通过以下方式联系博主\n 对博文进行评论，这样其他访客若有类似问题，也能起到一定的参考作用； 若喜欢私下交流，请采用邮件的方式进行联系。Email:linyihanchuan[AT]gmail[DOT]com   -- ","permalink":"https://blog.nickwhyy.top/about/","tags":null,"title":"关于"},{"categories":["安装"],"contents":"前言 首先确实是否安装了网卡驱动。\n1 2 3 4 5 6 7 8 9  $ ifconfig lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 3549 bytes 283497 (283.4 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3549 bytes 283497 (283.4 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0   lo开头的表示本地连接。如果没有en开头的，表示有线网卡驱动存在问题。因此，需要进一步确定网卡的驱动型号。\n1 2 3 4 5 6  $ lspci -v | grep Ethernet 00:1f.6 Ethernet controller: Intel Corporation Ethernet Connection (7) I219-V (r ev 10) DeviceName: Onboard - Ethernet Subsystem: Micro-Star International Co., Ltd. [MSI] Ethernet Connection (7) I219-V   百度一下，可知为e1000e驱动，上Intel的官网下载(https://downloadcenter.intel.com/download/15817/Intel-Network-Adapter-Driver-for-PCIe-Intel-Gigabit-Ethernet-Network-Connections-under-Linux-) 即可。我下载的目前最新的版本3.8.4。\n安装驱动 1 2 3 4 5 6  # 1.解压 $ tar zxf e1000e-3.8.4.tar.gz # 2.进入安装目录 $ cd e1000e-3.8.4/src # 3.安装 $ sudo make install   一般会安装在/lib/modules/`uname -r`/updates/drivers/net/ethernet/intel/e1000e/e1000e.ko下， 不过要让驱动能正常使用，需要将e1000e.ko复制到 /lib/modules/`uname -r`/kernel/drivers/net/ethernet/e1000e.ko中\n1 2 3 4 5 6 7 8  # 4.重载 $ sudo depmod -a # 5.Rebuild initramfs $ sudo update-initramfs -u -k all # 6.Check the driver version $ modinfo e1000e | grep version # 7.Load the driver module $ modprobe e1000e   之后，可能需要重启，然后再次确认ifconfig的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  $ ifconfig lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 3549 bytes 283497 (283.4 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3549 bytes 283497 (283.4 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 eno1: flags=4163 \u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet xxxx netmask xxxx inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 3549 bytes 283497 (283.4 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3549 bytes 283497 (283.4 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0   如果出现了en开头的字符，比如上面的eno1或其他字符，则表明网卡驱动安装成功。这时候， 如果打开Ubuntu的网络设置界面，可能仍然看不到关于有限网连接的菜单。但是，我们可以通过 在命令行手动设置一些网络参数来上网。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 8.将eno1设置为活动模式 $ sudo ip link set dev eno1 up # 9.进入网络设置目录 $ cd /etc/netplan # 10.修改其中的网络配置文件的参数 $ ls 01-netcfg.yaml # 下面是我修改的结果 $ cat 01-netcfg.yaml # This file describes the networks interfaces available on your system # For more information, see netplan(5). network: version: 2 renderer: networkd ethernets: eno1: dhcp4:yes   参数文件中的eno1需要和自己ifconfig所对应的en开头的名称一致。\n参考资料 [1] https://razeencheng.com/post/ubutun-realtek-r8125-driver-install\n[2] http://www.njcto.com/ubuntu-intel-e1000e.html\n[3] https://forum.openmediavault.org/index.php?thread/27791-troubles-with-the-installation-of-the-e1000e-intel-driver-i219-v/\n[4] https://my.oschina.net/u/4398725/blog/4743473\n修订历史  2021-03-11： 完成初稿  ","permalink":"https://blog.nickwhyy.top/post/wired/","tags":["Ubuntu","有线网卡","驱动"],"title":"Ubuntu 20.04 安装 e1000e 有线网卡驱动"},{"categories":["安装"],"contents":"前言 之前写过一篇关于在Windows 10上安装tensorflow的例子，这篇博文主要讨论如何在没有root权限的服务器的GPU节点上源码编译tensorflow.\n安装TensorFlow pip 软件包依赖项： 1 2 3  $ pip install -U --user pip six numpy wheel setuptools mock \u0026#39;future\u0026gt;=0.17.1\u0026#39; $ pip install -U --user keras_applications --no-deps $ pip install -U --user keras_preprocessing --no-deps   安装Bazel： 下载Bazel Bazel 版本必须在tensorflow/configure.py中指定的介于_TF_MIN_BAZEL_VERSION和_TF_MAX_BAZEL_VERSION之间的任一版本。\n从github上的Bazel项目上下载bazel-3.7.2-installer-linux-x86_64.sh.\n安装Bazel 1  $ bash bazel-3.7.2-installer-linux-x86_64.sh --prefix=~/soft/bazel-3.7.2   安装tensorflow 下载tensorflow 1  $ git clone https://github.com/tensorflow/tensorflow.git   配置build tensorflow 要求gcc的版本大于4.9，因此，可以在gpu节点上先enable gcc9的环境。\n1  $ scl enable devtoolset-9 bash   配置build\n1  $ ./configure   选择gcc9的环境，python3的环境，选择cuda，tensorRT不需要。\n编译 1  $ bazel build --config=v2 --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package   编译大概需要16 h\n构建whl 1  $ ./bazel-bin/tensorflow/tools/pip_package/build_pip_package --nightly_flag /tmp/tensorflow_pkg   安装软件包 1  $ pip install /tmp/tensorflow_pkg/tensorflow-version-tags.whl   报错 gcc 1  gcc: error: unrecognized command line option \u0026#39;-std=c++14\u0026#39;   主要原因是服务器的默认gcc版本是4.8.5， 采用scl 添加完gcc9的环境后，需要重新configure。\ngit 1  fatal: unable to find remote helper for \u0026#39;https\u0026#39;   把登陆节点的/usr/libexec/git-core 和/usr/bin/git都纳入到自己的PATH中，即可解决这个问题。\n参考资料  官方安装说明  修订历史  2021-01-10， 初稿  ","permalink":"https://blog.nickwhyy.top/post/instfnoroot/","tags":["tensorflow"],"title":"CentOS 7.8 源码编译 tensorflow 2.5"},{"categories":["地震学"],"contents":"Why 在初次使用Mineos软件时，为保证自己操作流程的正确性，一般会与自己之前熟悉的 软件进行一个结果的对比，这就要求输入的模型一致，震源参数一致，台站位置一致等。 本文主要解决输入模型一致的问题。\nAxiSEM模型文件和Mineos模型文件简介 通过观察，可以发现Mineos所使用的模型的结构与AxiSEM十分类似。下面是具体的模型 文件对比 AxiSEM\n1 2 3 4 5 6 7 8 9 10 11 12  # Input file for AXISEM created from prem_ani model on 07/08/2020, at 16h 44min NAME prem_ani ANELASTIC T ANISOTROPIC T UNITS m COLUMNS radius rho vpv vsv vph vsh eta qka qmu 6371000. 2600.00 5800.00 3200.00 5800.00 3200.00 1.00000 0.57827000E+05 0.60000000E+03 6356000. 2600.00 5800.00 3200.00 5800.00 3200.00 1.00000 0.57827000E+05 0.60000000E+03 # Discontinuity 1, depth: 15.00 km 6356000. 2900.00 6800.00 3900.00 6800.00 3900.00 1.00000 0.57827000E+05 0.60000000E+03 6346600. 2900.00 6800.00 3900.00 6800.00 3900.00 1.00000 0.57827000E+05 0.60000000E+03   Mineos\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  Anisotropic PREM 1 0 1 160 26 73 1 0. 13088.50 11262.20 3667.80 0.13277000E+04 0.84599998E+02 11262.20 3667.80 1.00000 21500. 13088.40 11262.13 3667.75 0.13277000E+04 0.84599998E+02 11262.13 3667.75 1.00000 71500. 13087.39 11261.40 3667.24 0.13277000E+04 0.84599998E+02 11261.40 3667.24 1.00000 121500. 13085.29 11259.89 3666.18 0.13277000E+04 0.84599998E+02 11259.89 3666.18 1.00000 171500. 13082.10 11257.59 3664.58 0.13277000E+04 0.84599998E+02 11257.59 3664.58 1.00000 221500. 13077.82 11254.51 3662.42 0.13277000E+04 0.84599998E+02 11254.51 3662.42 1.00000 271500. 13072.45 11250.64 3659.72 0.13277000E+04 0.84599998E+02 11250.64 3659.72 1.00000 321500. 13065.99 11245.99 3656.47 0.13277000E+04 0.84599998E+02 11245.99 3656.47 1.00000 371500. 13058.45 11240.56 3652.68 0.13277000E+04 0.84599998E+02 11240.56 3652.68 1.00000 421500. 13049.82 11234.34 3648.33 0.13277000E+04 0.84599998E+02 11234.34 3648.33 1.00000 471500. 13040.09 11227.34 3643.44 0.13277000E+04 0.84599998E+02 11227.34 3643.44 1.00000   可以发现，AxiSEM的输入模型有对变量含义的解释，以及对间断面的注释；而mineos则需要参考Manual或者源代码来确认模型 中每个参数的具体意义。具体解释如下：\nMineos的第2行的第1个数字取值为（1：横向各向同性(TI)；0：各向同性）；第2个数字与衰减有关(\u0026lt;=0: 不含衰减)；第3个是 模型的类型（1：层状格式；0：多项式形式）\nMineos的第3行的第1个数字取值为模型的最大半径所在行数（不包括前面3行，也就是整个模型部分共多少行）；第2个数字为ICB 所在的行数（不包括前3行）；第3个数字为CMB所在的行数（不包括前3行）；第4个数字为0则所有半径的结果都存储，为1则表示在 6330km以上以及不连续面两侧全部存储，其他位置以1 sample/km存储。\nMineos的第4行开始，每列的含义为（r, rho, vpv, vsv, qkappa, qshear, vph, vsh, eta）\n模型转换 可以发现，除注释的部分外，AxiSEM 模型文件和 Mineos 十分相似，最大的特征是AxiSEM 的模型是从地表一直往下，而 Mineos则 是从地心到地表，因此，需要把整个文件在纵向上做一个reverse 变换。最简单的方法是采用一行perl语句：\n1  $ perl -e \u0026#39;print reverse \u0026lt;\u0026gt;\u0026#39; axisem.txt \u0026gt; mineos.txt   接下来，可以用vim删除掉所有的注释行，得到一个纯数值的文件。\n然后，继续观察，我们发现mineos前4列与 axisem完全一致， 后面的几列有一些位置的改变，这个可通过awk命令来调整列的顺序：\n1  $ awk \u0026#39;{print $1,$2,$3,$4,$8,$9,$5,$6,$7}\u0026#39; mineos.txt \u0026gt; premANIC.card   最后， 将mineos前面三行按照模型以及模拟的要求填好即可。不过，另外也可以写一个脚本将整个流程串起来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #!/bin/bash  # reverse row order perl -e \u0026#39;print reverse \u0026lt;\u0026gt;\u0026#39; axisem.txt \u0026gt; tmp.txt # remove comment lines # grep -v \u0026#39;^#\u0026#39;: remove the lines begin with # # grep -v \u0026#39;^[A-Z]\u0026#39;: remove the lines begin with [A-Z] cat tmp.txt | grep -v \u0026#39;^#\u0026#39; | grep -v \u0026#39;^[A-Z]\u0026#39; \u0026gt; tmp2.txt # change the order of columns awk \u0026#39;{print $1,$2,$3,$4,$8,$9,$5,$6,$7}\u0026#39; tmp2.txt \u0026gt; mineos.card # add comments in the begining sed -i \u0026#39;1 i\\Anisotropic PREM \\n 1 0 1 \\n 160 26 73 1\u0026#39; mineos.card rm -rf tmp*.txt   修订历史  2020-09-29：初稿；  参考资料  https://blog.csdn.net/baidu_33615716/article/details/78871190 https://blog.csdn.net/aywb1314/article/details/52239281 https://jingyan.baidu.com/article/f71d6037ddd3c11ab641d1ee.html https://blog.csdn.net/gsjthxy/article/details/106917101  ","permalink":"https://blog.nickwhyy.top/post/axisem2mineos/","tags":["AxiSEM","Mineos"],"title":"AxiSEM 模型转化为 Mineos"},{"categories":["安装"],"contents":"下载 要下载AxiSEM3D，可以在终端中输入以下命令：\n1  $ git clone https://github.com/kuangdai/AxiSEM3D   安装依赖包  mpi并行环境，可安装不带 MPI 加速的版本 METIS 安装版本大于5.1， 只需安装32位的版本即可 Boost 安装的版本要大于1.60, 直接下载解压即可 Eigen3 安装的版本要大于3.3-rc1， 直接下载解压即可 FFTW 安装版本要大于3.3， 需要安装双精度和单精度两个版本 NetCDF 安装版本大于4.4 zlib NetCDF的依赖项，暂无版本要求，建议1.2.8以上 hdf5 NetCDF的依赖项，暂无版本要求，建议1.8.12以上  FFTW 由于MPi并行环境，metis之前已写过安装教程，可自行参考上面的链接查看或看官网给的安装说明。\nBoost和Eigen3只需要下载软件，解压即可，不在此过多讨论。\nFFTW的安装过程比较简单，其安装过程如下\n1 2 3 4 5 6 7 8 9 10 11 12  # 下载软件 $ wget http://www.fftw.org/fftw-3.3.8.tar.gz # 解压软件 $ tar -xvf fftw-3.3.8.tar.gz # 配置双精度版本 $ cd fftw-3.3.8 $ ./configure --prefix=${HOME}/.axisem3d_depends/fftw-3.3.8 $ make -j # 配置单精度版本 $ ./configure --enable-float --prefix=${HOME}/.axisem3d_depends/fftw-3.3.8 $ make -j $ make install   zlib的安装 1 2 3 4 5 6 7 8 9 10  # 下载 $ wget https://zlib.net/zlib-1.2.8.tar.gz # 解压 $ tar -xvf zlib-1.2.8.tar.gz # 安装 $ cd zlib-1.2.8 $ ZDIR=${HOME}/.axisem3d_depends/zlib-1.2.8 $ ./configure --prefix=${ZDIR} $ make check $ make install   hdf5的安装 1 2 3 4 5 6 7 8 9 10  # 下载 $ wget https://support.hdfgroup.org/ftp/HDF5/prev-releases/hdf5-1.8/hdf5-1.8.12/src/hdf5-1.8.12.tar.gz # 解压 $ tar -xvf hdf5-1.8.12.tar.gz # 安装 $ cd hdf5-1.8.12 $ H5DIR=${HOME}/.axisem3d_depends/hdf5-1.8.12 $ ./configure --with-zlib=${ZDIR} --prefix=${H5DIR} --enable-hl $ make check $ make install   NetCDF的安装 1 2 3 4 5 6 7 8  # 下载 $ git clone http://github.com/Unidata/netcdf-c netcdf-c # 安装 $ cd netcdf-c $ NCDIR=${HOME}/.axisem3d_depends/netcdf-c $ CPPFLAGS=\u0026#39;-I${H5DIR}/include -I${ZDIR}/include\u0026#39; LDFLAGS=\u0026#39;-L${H5DIR}/lib -L${ZDIR}/lib\u0026#39; ./configure --prefix=${NCDIR} $ make check $ make install   AxiSEM3D 配置依赖项 编辑$AxiSEM3D_SRC下的axisem3d_depends.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  export MY_CONDA_INSTALL_DIR=/home/opt/anaconda3/2020.02 # Ubuntu default export MY_BASH_PROFILE_UBT=$HOME/.bashrc # What do you have already? And where are they? # boost export MY_BOOST_READY=true export MY_BOOST_DIR=$HOME/.axisem3d_depends/boost # eigen3 (make sure it is above 3.3-rc1, very important) export MY_EIGEN3_READY=true export MY_EIGEN3_DIR=$HOME/.axisem3d_depends/eigen3 # fftw (make sure it contains both double- and single-precision) export MY_FFTW_READY=true export MY_FFTW_DIR=$HOME/.axisem3d_depends/fftw-3.3.8 # Metis (make sure it is built with 32-bit) export MY_METIS_READY=true export MY_METIS_DIR=$HOME/.axisem3d_depends/metis-5.1.0 # NetCDF export MY_NETCDF_READY=true export MY_NETCDF_DIR=$HOME/.axisem3d_depends/netcdf-c # where you would like to download boost and eigen3 export BOOST_INSTALL_DIR=$HOME/.axisem3d_depends/boost export EIGEN3_INSTALL_DIR=$HOME/.axisem3d_depends/eigen3   安装 1 2 3 4 5 6 7 8 9  # build, my_axisem3d_build和AxiSEM3D是同一级目录 $ mkdir my_axisem3d_build $ ls AxiSEM3D my_axisem3d_build $ cd my_axisem3d_build # cmake $ cmake -DCMAKE_BUILD_TYPE=release ../AxiSEM3D/SOLVER # compile and link $ make -j   测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  ########## run ########## # make a simulation directory mkdir my_second_run cd my_second_run # copy the executable cp ../my_axisem3d_build/axisem3d ./ # copy the input folder cp -R ../AxiSEM3D/template/input ./ # Though optional, it is always a good practice # to backup the source code for reproducibility: cp -r ../AxiSEM3D/SOLVER ./ # run it with any number of processors mpirun -np 4 ./axisem3d # check the outputs ls output   修订历史  2020-09-02：初稿；  参考资料  http://www.fftw.org/fftw3_doc/Installation-on-Unix.html https://github.com/kuangdai/AxiSEM3D https://www.unidata.ucar.edu/software/netcdf/docs/getting_and_building_netcdf.html https://www.cnblogs.com/fsquared/p/3804863.html  ","permalink":"https://blog.nickwhyy.top/post/axisem3d/","tags":["AxiSEM3D"],"title":"Linux 下安装 AxiSEM3D"},{"categories":["安装"],"contents":"在有 root 的权限下安装 Madagascar 比较容易，请参考 https://blog.nickwhyy.top/post/madagascar/。 本文主要探讨在没有 root 权限的场合下（比如服务器上）安装 Madagascar。\n本人所用的服务器是 CentOS 7.5 系统，正常安装依赖包直接用 yum 安装即可，但在没有 root 的权限下 无法直接安装各种依赖包，一般有两种方式来安装软件：\n 1.去网上找一些 rpm 包，然后将其解压，并添加路径到~/.bashrc； 2.找相关安装包的源代码，然后手动编译。  一般而言，安装不带 sfpen 的 Madagascar 十分容易，直接在 src目录下运行 ./configure然后 再make, make install即可安装成功。但sfpen程序依赖于 libXaw-devel 图形库，因此，必须 先安装该软件包，才能安装一个比较完整的 Madagascar。\nlibX*相关的源代码可在ftp://mirror.csclub.uwaterloo.ca/x.org/X11R7.7-RC1/src/lib/上进行 下载。下面以安装libXaw为例，简单进行说明\n编译，安装libXaw 1 2 3 4 5  $ tar -xvf libXaw-1.0.10.tar.gz $ cd libXaw-1.0.10 $ ./configure --prefix=/home/lloyd/.local $ make $ make install     这里大概率会提示缺少xt等，需要上ftp://mirror.csclub.uwaterloo.ca/x.org/X11R7.7-RC1/src/lib/ 下载libXt*.tar.gz,然后按照上面的步骤安装libXt，可能会提示缺少ICE等，继续按照上面的操作流程， 补完对应缺少的依赖包，每一个依赖包都按照解压, configure， make， make install四部曲进行。\n  可能遇到了问题是，比如ICE依赖xtrans，我装完了xtrans,回过来再装ICE,结果提示系统里找不到xtrans， 然后可能想到，把xtrans的安装路径下的lib添加到LD_LIBRARY_PATH中，结果发现还是没用。主要原因在于 configure调用了系统的pkg_config程序，而系统的pkg_config程序不会搜索非标准目录(如/usr/lib)下安装的程序, 因此，需要将xtrans的pkgconfig路径添加到系统的PKG_CONFIG_PATH中，具体操作如下,在~/.bashrc中添加：\n1 2  export PKG_CONFIG_PATH=${PKG_CONFIG_PATH}:${HOME}/.local/share/pkgconfig export PKG_CONFIG_PATH=${PKG_CONFIG_PATH}:${HOME}/.local/lib/pkgconfig   重复刚才的所有操作，应该就能成功地安装libXaw了，然后开始安装 Madagascar。\n编译，安装 Madagascar 进入Madagascar的源文件根目录，输入configure API=c++,f90,matlab,python --prefix=/home/lloyd/.local/rsf ,结果发现configure的结果中X11是 no，但是刚才的那步确实是安装了libXaw，这时需要修改framework/configure.py, 找到里面的xinc, xlib， 将自己刚才安装libXaw的路径补充进去，然后重新configure, 即可解决刚才的问题，从而安装 一个比较完整的Madagascar，剩下的安装步骤见https://blog.nickwhyy.top/post/madagascar/。\nlibXaw安装方式2 上这个https://centos.pkgs.org/7/centos-x86_64/libXaw-devel-1.0.13-4.el7.x86_64.rpm.html下载libXaw-devel*.rpm 包，然后查看该软件包所依赖的其它软件包(即网页中的Requires一栏)，逐个下载依赖包，然后check每个依赖包对应需要下载 的其它依赖软件，将所有的依赖软件都下载下来。且放在同一个文件夹下，运行下面的命令，并将libXaw-devel-1.0.13-4.el7.x86_64.rpm换成刚才下载的其它软件包的名称，依次解压软件包到usr文件夹下。然后你会发现usr目录下会有include，lib等目录， 将include和lib分别添加到Madagascar的$RSFSRC/framework/configure.py中的xinc 和 xlib中，然后就可以安装 完整的Madagascar了。\n1  $ rpm2cpio libXaw-devel-1.0.13-4.el7.x86_64.rpm | cpio -idvm     注意，方法2仅仅是理论上可行，本人未进行测试。如果测试有问题，可转向方法1，进行源码编译，一般不会有太大的问题。\n修订历史  2020-08-13: 初稿；  ","permalink":"https://blog.nickwhyy.top/post/madagascar_noroot/","tags":["Madagascar"],"title":"在没有 root 权限的情况下安装 Madagascar"},{"categories":["安装"],"contents":"前言 首先确认网卡为RTL8821CE类型，可通过在windows系统下查看 设备型号来进行确认。\n驱动下载 1  $ git clone https://github.com/tomaspinho/rtl8821ce.git   下载好该驱动后，需要checkout到5fd6714分支(我本人下载的时候正好 处于该分支)。\n1 2  $ cd rtl8821ce $ git checkout 5fd6714   安装依赖包 需要安装下列依赖包:\n1 2  $ sudo apt install bc module-assistant build-essential dkms $ sudo m-a prepare   安装 1  $ sudo ./dkms-install.sh   命令执行完毕后重新启动即可。\n参考资料 https://github.com/tomaspinho/rtl8821ce\n修订历史  2020-01-13： 完成初稿  ","permalink":"https://blog.nickwhyy.top/post/wireless/","tags":["Ubuntu","无线网卡","驱动"],"title":"Ubuntu 18.04 安装 RTL8821CE 无线网卡驱动"},{"categories":["安装"],"contents":"前言 SEPlib的源码已托管在GitLab上,目前的版本是9.0。\n软件下载 1  $ git clone http://zapad.Stanford.EDU/bob/SEPlib.git   安装依赖包 安装前先安装SU，另外还需要安装下列依赖包:\n1 2 3 4  $ sudo apt-get install -y cmake libxaw7-dev g++ flex libfftw3-single3 libfftw3-dev python3-dev python3-pytest python3-numpy-dbg libtbb-dev libboost-all-dev libboost-dev   基础安装 SEPlib 9.0 已经改为采用 cmake 来安装，且对 cmake 的 版本有要求，建议安装最新版本的 cmake。\n1 2 3 4 5 6 7  # 进入 SEPlib 源代码的根目录 # 在根目录下新建`build`文件夹 $ mkdir build $ cd build $ cmake -DCMAKE_INSTALL_PREFIX=/opt/SEP .. $ make $ sudo make install   可能出现的错误信息 错误信息可能会出现在安装画图相关的库，如果报错，可以先在 $SEPSRC/CMakeLists.txt文件中的下面这几行注释掉或删除\n1 2 3  if(BUILD_VPLOT_GRAPHICS) add_subdirectory(progs/vplot) endif(BUILD_VPLOT_GRAPHICS)   然后再编译即可。因为图形相关的库可用Madagascar的画图库来打开 这些文件。另外大家也可以可以尝试分析编译出错的原因，然后一步步地 解决问题。\n环境变量的设置 在自己的~/.bashrc\n1 2  export SEPROOT=/opt/SEP export PATH=$PATH:$SEPROOT/bin   修订历史  2019-11-04： 最新版的SEPlib安装  ","permalink":"https://blog.nickwhyy.top/post/seplib/","tags":["SEPlib","Linux","地震学软件"],"title":"Linux 下安装 SEPlib 9.0"},{"categories":["安装"],"contents":"前言 本文介绍如何在Ubuntu 16.04 LTS 系统上配置目标检测框架 Detectron。其他软件版本如下：\n Python 3.6 CUDA 9.0 cuDNN 7.3  Detectron 是 Facebook AI 研究组开发的一个实现了目前主流目标识别方法的软件，该软件基于 caffe2 框架上。而 caffe2 又集成于 PyTorch 中，所以需要安装PyTorch.\n安装PyTorch 建议手动编译PyTorch，整个过程比较简单。具体如下：\n安装依赖项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  $ sudo apt-get update $ sudo apt-get install -y --no-install-recommends \\ build-essential \\ git \\ libgoogle-glog-dev \\ libgtest-dev \\ libiomp-dev \\ libleveldb-dev \\ liblmdb-dev \\ libopencv-dev \\ libopenmpi-dev \\ libsnappy-dev \\ libprotobuf-dev \\ openmpi-bin \\ openmpi-doc \\ protobuf-compiler \\ python-dev \\ python-pip $ pip install --user \\ future \\ numpy \\ protobuf \\ typing \\ hypothesis # for Ubuntu 16.04 $ sudo apt-get install -y --no-install-recommends \\ libgflags-dev \\ cmake   安装CUDA 参见另外一篇博文\n复制Pytorch仓库代码并安装 1 2 3  $ git clone https://github.com/pytorch/pytorch.git \u0026amp;\u0026amp; cd pytorch $ git submodule update --init --recursive $ python setup.py install   测试caffe2是否安装成功 1  $ cd ~ \u0026amp;\u0026amp; python -c \u0026#39;from caffe2.python import core\u0026#39; 2\u0026gt;/dev/null \u0026amp;\u0026amp; echo \u0026#34;Success\u0026#34; || echo \u0026#34;Failure\u0026#34;   如果现实Success则安装成功。\n安装Detectron 安装COCO API 1 2 3 4 5  $ export COCOAPI=/home/lloyd/cocoapi $ git clone https://github.com/cocodataset/cocoapi.git $COCOAPI $ cd $COCOAPI/PythonAPI $ make install $ python setup.py install --user   Detectron 1 2 3 4  $ export DETECTRON=/home/lloyd/detectron $ git clone https://github.com/facebookresearch/detectron $DETECTRON $ pip install -r $DETECTRON/requirements.txt $ cd $DETECTRON \u0026amp;\u0026amp; make   测试 1  $ python $DETECTRON/detectron/tests/test_spatial_narrow_as_op.py   错误汇总      ValueError: numpy.ufunc size changed, may indicate binary incompatibility. Expected 216 from C header, got 192 from PyObject\n原因，numpy版本问题，经测试numpy==1.16.1版本不会出现该问题。\n    ImportError: numpy.core.multiarray failed to import\n原因仍是numpy版本问题，经测试numpy==1.16.1版本不会出现该问题。\n    1 2  yaml.constructor.ConstructorError: while constructing a Python instance expected a class, but found \u0026lt;class \u0026#39;builtin_function_or_method\u0026#39;\u0026gt;   解决方案： 在detectron/utils/env.py文件中将yaml_load = yaml.load改为 yaml_load = lambda x: yaml.load(x, Loader=yaml.Loader)即可。\n参考资料  caffe2官网 ValueError: numpy.ufunc size changed) yaml.constructor.ConstructorError  修订历史  2019-06-23， 初稿  ","permalink":"https://blog.nickwhyy.top/post/installdetectron/","tags":["caffe2","Pytorch","Detectron"],"title":"目标检测框架 Detectron 在 Linux 上的配置"},{"categories":["安装"],"contents":"前言 本文介绍如何在Ubuntu 16.04 LTS 系统上配置目标检测框架 SSD。其他软件版本如下：\n Python 3.6 CUDA 8.0  由于 SSD 是在 caffe 框架上建立的，所以得先安装 caffe， 具体见另一篇博文. 成功安装caffe后，我们进入到 SSD 的配置。\n数据准备  下载 fully convolutional reduced (atrous) VGGNet. 并将其存储于$CAFFE_ROOT/models/VGGNet/下。 下载 VOC2007 和 VOC2012 数据集. 并将其存储于 $HOME/data/下。  1 2 3 4 5 6 7 8 9  # 下载数据集 $ cd $HOME/data $ wget http://host.robots.ox.ac.uk/pascal/VOC/voc2012/VOCtrainval_11-May-2012.tar $ wget http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtrainval_06-Nov-2007.tar $ wget http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtest_06-Nov-2007.tar # 解压缩 $ tar -xvf VOCtrainval_11-May-2012.tar $ tar -xvf VOCtrainval_06-Nov-2007.tar $ tar -xvf VOCtest_06-Nov-2007.tar   创建LMDB文件。  1 2 3 4 5 6 7 8 9  $ cd $CAFFE_ROOT # Create the trainval.txt, test.txt, and test_name_size.txt in data/VOC0712/ $ ./data/VOC0712/create_list.sh # You can modify the parameters in create_data.sh if needed. # It will create lmdb files for trainval and test with encoded original image: # - $HOME/data/VOCdevkit/VOC0712/lmdb/VOC0712_trainval_lmdb # - $HOME/data/VOCdevkit/VOC0712/lmdb/VOC0712_test_lmdb # and make soft links at examples/VOC0712/ $ ./data/VOC0712/create_data.sh   其中，create_data.sh这一步可能会报错，内容如下\n  ImportError: No module named caffe.proto\n解决方案： 在~/.bashrc文件中添加下面两行\n1 2  export CAFFE_ROOT=$HOME/caffe # 按照自己caffe的安装目录填写即可 export PYTHONPATH=$CAFFE_ROOT/python:$PYTHONPATH   然后，接着执行create_data.sh,可能会报如下错误：\n  ImportError: dynamic module does not define module export function (PyInit__caffe)\n解决方案： 这问题是编译caffe时所选的版本和自己目前环境变量中python版本不一致导致的，需要重新编译caffe。修改 Makefile.config文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 注释掉Python2.7相关的语句 #PYTHON_INCLUDE := /usr/include/python2.7 \\ #\t/usr/lib/python2.7/dist-packages/numpy/core/include # 选择 anaconda python3.6， 注意这里选择自己对应的anaconda的安装位置，以及自己anaconda虚拟环境 所创建的python 3.6的名称 ANACONDA_HOME := $(HOME)/anaconda3/envs/py36 PYTHON_INCLUDE := $(ANACONDA_HOME)/include \\ $(ANACONDA_HOME)/include/python3.6m \\ $(ANACONDA_HOME)/lib/python3.6/site-packages/numpy/core/include # 更改PYTHON_LIB #PYTHON_LIB := /usr/lib PYTHON_LIB := $(ANACONDA_HOME)/lib   修改之后，重新编译caffe\n1 2 3 4 5  $ make clean $ make -j8 $ make py # 运行 create_data.sh $ ./data/VOC0712/create_data.sh   此时，可能会出现新的错误：\n  ImportError: /home/lloyd/caffe/python/caffe/_caffe.so: undefined symbol: _ZN5boost6python6detail11init_moduleER11PyModuleDefPFvvE\n错误产生原因： boost_python的版本不匹配，使用的python版本为3.6，而/usr/lib/x86_64-linux-gnu/下没有对应 python 3.6版本的库文件。\n解决方案： 安装boost_python,采用python3.6的环境进行编译。\n1 2 3 4 5 6 7 8  # 下载安装包 wget -O boost_1_67_0.tar.gz http://sourceforge.net/projects/boost/files/boost/1.67.0/boost_1_67_0.tar.gz/download # 解压缩 tar xzvf boost_1_67_0.tar.gz # 进入boost目录 cd boost_1_67_0/ # configure ./bootstrap.sh --prefix=/home/lloyd/boost --with-python=/home/lloyd/anaconda3/envs/py36/bin/python3 --with-python-root=/home/lloyd/anaconda3/envs/py36 --with-python-version=3.6   修改project-config.jam文件 原文件为：\n1 2 3 4 5 6  # Python configuration import python ; if ! [ python.configured ] { using python : 3.6 : /home/lloyd/anaconda3/envs/py36 ; }   修改后为：\n1 2 3 4 5 6  # Python configuration import python ; if ! [ python.configured ] { using python : 3.6 : /home/lloyd/anaconda3/envs/py36 : /home/lloyd/anaconda3/envs/py36/include/python3.6m : /home/lloyd/anaconda3/envs/py36/lib ; }   然后修改tools/build/src/tools/python.jam文件第547行， 原文件为：\n1  includes ?= $(prefix)/include/python$(version) ;   修改为：\n1  includes ?= $(prefix)/include/python$(version)m ;   之后，编译，安装即可：\n1 2 3 4 5 6 7  $ ./b2 $ ./b2 install # 复制库文件到系统库文件，建立软链接 $ sudo cp /home/lloyd/boost/lib/libboost_python36.a /usr/lib/x86_64-linux-gnu/libboost_python_python36.a $ sudo cp /home/lloyd/boost/lib/libboost_python36.so.1.67.0 /usr/lib/x86_64-linux-gnu/libboost_python36.so.1.67.0 $ sudo cp /home/lloyd/boost/lib/libboost_python36.so /usr/lib/x86_64-linux-gnu/libboost_python36.so $ sudo ln /usr/lib/x86_64-linux-gnu/libboost_python36.so /usr/lib/x86_64-linux-gnu/libboost_python3.so   接着，回到$CAFFE_ROOT，然后继续运行create_data.sh,就能正确地创建数据文件了。\n训练 首先修改examples/ssd/ssd_pascal.py一些与数据存储位置相关的参数以及GPU信息。然后运行下面的命令\n1  $ python examples/ssd/ssd_pascal.py   可能出现如下错误：\n  File \u0026quot;examples/ssd/ssd_pascal.py\u0026quot;, line 314, in \u0026lt;module\u0026gt; for ratio in xrange(min_ratio, max_ratio + 1, step): NameError: name 'xrange' is not defined\n主要原因是在Python 3中，range()与xrange()合并为range()。因此修改examples/ssd/ssd_pascal.py 中的xrange为range即可。\n然后继续运行python examples/ssd/ssd_pascal.py,可能出现的错误有：\n  assert len \u0026gt; 0 TypeError: '\u0026gt;' not supported between instances of 'builtin_function_or_method' and 'int'\n修改策略是注释掉model_libs.py中函数UnpackVariable定义中与assert相关的语句。\n然后继续运行python examples/ssd/ssd_pascal.py,可能出现的错误有：\n  getattr(proto, name).extend(val) TypeError: 1.0 has type float, but expected one of: int, long\n原因是在python3中 / 的结果是 float 导致的. 解决方法： 修改python/caffe/net_spec.py文件中含有dilation且含有/的语句，一共三条。比如：\n1 2  # pad = int((3 + (dilation - 1) * 2) - 1) / 2 # 原文件 pad = int((3 + (dilation - 1) * 2) - 1) // 2 # 修改后   按照此策略，依次修改掉其他的另外两行语句。\n然后继续运行python examples/ssd/ssd_pascal.py，就能顺利训练数据了。\n参考资料  SSD官方repo ImportError: No module named caffe.proto ImportError: dynamic module does not define module export function (PyInit__caffe) undefined symbol: _ZN5boost6python6detail11init_moduleER11PyModuleDefPFvvE boost_python3 安装 cannot find -lboost_python3 boost_python3 配置 boost1.65.1库编译报错，找不到 pyconfig.h getattr(proto, name).extend(val)  修订历史  2019-06-16， 初稿  ","permalink":"https://blog.nickwhyy.top/post/installssd/","tags":["caffe","SSD"],"title":"目标检测算法 SSD 在 Linux 上的配置"},{"categories":["安装"],"contents":"前言 CAFFE（快速特征嵌入的卷积结构，Convolutional Architecture for Fast Feature Embedding）是一个深度学习框架，最初开发于加利福尼亚大学伯克利分校。 我们按照官方的说明网页来介绍如何在Ubuntu 16.04 LTS系统上手工编译安装该软件。\n安装依赖包 一般依赖项 1 2  sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler sudo apt-get install --no-install-recommends libboost-all-dev   特殊依赖软件  CUDA 安装见另外一篇博文  安装 下载caffe 由于我安装caffe的目的是跑SSD代码，所以选择的是weiliu89的fork分支进行安装。\n1 2 3  $ git clone https://github.com/weiliu89/caffe.git $ cd caffe $ git checkout ssd   编译 我们先尝试编译一下代码，然后在遇到问题的过程中逐步解决问题。\n1 2 3  # Modify Makefile.config according to your Caffe installation. $ cp Makefile.config.example Makefile.config $ make -j8   此时，可能会出现错误一：\n  .build_release/src/caffe/proto/caffe.pb.h:9:42: fatal error: google/protobuf/stubs/common.h: No such file or directory\n错误一解决方案：\n1 2 3  $ sudo apt-get install libprotobuf-dev protobuf-compiler # 继续编译 $ make -j8   此时，可能会出现错误二：\n  ./include/caffe/common.hpp:5:27: fatal error: gflags/gflags.h: No such file or directory\n错误二解决方案：\n1 2 3  $ sudo apt-get install libprotobuf-dev protobuf-compiler # 继续编译 $ make -j8   此时，可能会出现错误三：\n  ./include/caffe/common.hpp:6:26: fatal error: glog/logging.h: No such file or directory\n错误三解决方案：\n1 2 3  $ sudo apt-get install libgoogle-glog-dev # 继续编译 $ make -j8   此时，可能会出现错误四：\n  ./include/caffe/util/device_alternate.hpp:34:23: fatal error: cublas_v2.h: No such file or directory\n错误四产生原因：\n  没有把cuda的头文件、库的路径放置到caffe的Makefile.config中\n错误四解决方案： 在Makefile.config文件中添加下列两行，具体位置可放在# If Homebrew is installed at a non standard location (for example your home directory) and you use it for general dependencies这句话下面。\n1 2  INCLUDE_DIRS += /usr/local/cuda-8.0/include LIBRARY_DIRS += /usr/local/cuda-8.0/lib64   修改完后，继续编译make -j8\n此时，可能会出现错误五：\n  ./include/caffe/util/mkl_alternate.hpp:14:19: fatal error: cblas.h: No such file or directory\n错误五解决方案：\n1 2 3  $ sudo apt-get install libopenblas-dev # 继续编译 $ make -j8   此时，可能会出现错误六：\n src/caffe/layers/hdf5_data_layer.cpp:13:18: fatal error: hdf5.h: No such file or directory\n 错误六解决方案： 第一步，先安装下面的依赖包\n1  $ sudo apt install libhdf5-serial-dev   第二步，编辑Makefile.config文件 原文件为：\n1 2 3  # Whatever else you find you need goes here. INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib   现在修改为：\n1 2 3  # Whatever else you find you need goes here. INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial/ LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu/hdf5/serial/   第三步，编辑Makefile文件 原文件为：\n1  LIBRARIES += glog gflags protobuf boost_system boost_filesystem m hdf5_hl hdf5   现修改为：\n1  LIBRARIES += glog gflags protobuf boost_system boost_filesystem m hdf5_serial_hl hdf5_serial   修改完后，继续编译make -j8\n此时，可能会出现错误七：\n  ./include/caffe/util/db_leveldb.hpp:7:24: fatal error: leveldb/db.h: No such file or directory\n错误七解决方案：\n1 2 3  $ sudo apt-get install libleveldb-dev # 继续编译 $ make -j8   此时，可能会出现错误八：\n  ./include/caffe/util/db_lmdb.hpp:8:18: fatal error: lmdb.h: No such file or directory\n错误八解决方案：\n1 2 3  $ sudo apt-get install liblmdb-dev # 继续编译 $ make -j8   此时，可能会出现错误九：\n  /usr/bin/ld: cannot find -lsnappy\n错误九解决方案：\n1 2 3  $ sudo apt-get install libsnappy-dev # 继续编译 $ make -j8   这时候，基本上就可以成功编译了。\n接着，继续执行下列命令：\n1 2 3  $ make py $ make test -j8 $ make runtest -j8   此时，可能会出现错误十：\n  .build_release/tools/caffe: error while loading shared libraries: libcudart.so.8.0: cannot open shared object file: No such file or directory\n错误十解决方案： 在~/.bashrc文件中添加\n1  export LIBRARY_PATH=$LIBRARY_PATH:/usr/local/cuda-8.0/lib64   之后再执行make runtest -j8，就会顺利地跑测试程序，不出意外的话，可得到如下结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  $ make runtest -j8 .build_release/tools/caffe caffe: command line brew usage: caffe \u0026lt;command\u0026gt; \u0026lt;args\u0026gt; commands: train train or finetune a model test score a model device_query show GPU diagnostic information time benchmark model execution time Flags from tools/caffe.cpp: -gpu (Optional; run in GPU mode on given device IDs separated by \u0026#39;,\u0026#39;.Use \u0026#39;-gpu all\u0026#39; to run on all available GPUs. The effective training batch size is multiplied by the number of devices.) type: string default: \u0026#34;\u0026#34; -iterations (The number of iterations to run.) type: int32 default: 50 -level (Optional; network level.) type: int32 default: 0 -model (The model definition protocol buffer text file.) type: string default: \u0026#34;\u0026#34; -phase (Optional; network phase (TRAIN or TEST). Only used for \u0026#39;time\u0026#39;.) type: string default: \u0026#34;\u0026#34; -sighup_effect (Optional; action to take when a SIGHUP signal is received: snapshot, stop or none.) type: string default: \u0026#34;snapshot\u0026#34; -sigint_effect (Optional; action to take when a SIGINT signal is received: snapshot, stop or none.) type: string default: \u0026#34;stop\u0026#34; -snapshot (Optional; the snapshot solver state to resume training.) type: string default: \u0026#34;\u0026#34; -solver (The solver definition protocol buffer text file.) type: string default: \u0026#34;\u0026#34; -stage (Optional; network stages (not to be confused with phase), separated by \u0026#39;,\u0026#39;.) type: string default: \u0026#34;\u0026#34; -weights (Optional; the pretrained weights to initialize finetuning, separated by \u0026#39;,\u0026#39;. Cannot be set simultaneously with snapshot.) type: string default: \u0026#34;\u0026#34; .build_release/test/test_all.testbin 0 --gtest_shuffle Cuda number of devices: 1 Setting to use device 0 Current device id: 0 Current device name: GeForce GTX 1060 3GB Note: Randomizing tests\u0026#39; orders with a seed of 17807 . [==========] Running 2301 tests from 299 test cases. [----------] Global test environment set-up. [----------] 8 tests from LRNLayerTest/3, where TypeParam = caffe::GPUDevice\u0026lt;double\u0026gt; [ RUN ] LRNLayerTest/3.TestSetupWithinChannel [ OK ] LRNLayerTest/3.TestSetupWithinChannel (1471 ms) [ RUN ] LRNLayerTest/3.TestSetupAcrossChannels ... [----------] Global test environment tear-down [==========] 2301 tests from 299 test cases ran. (372301 ms total) [ PASSED ] 2301 tests.   最后的PASSED表示全部测试都通过了，说明安装成功。\n参考资料  官方安装文档 caffe编译的问题解决：“cublas_v2.h: No such file or directory” error \u0026lsquo;google/protobuf/stubs/common.h\u0026rsquo; libcudart.so.8.0: cannot open shared object file ubuntu16.04+cuda8.0.44+cudnn5.1.5+caffe问题集 WIKI github  修订历史  2019-06-15， 初稿  ","permalink":"https://blog.nickwhyy.top/post/installcaffe/","tags":["caffe"],"title":"Linux 安装 caffe"},{"categories":["安装"],"contents":"前期准备 Keras 是一个用Python 编写的高级神经网络API，它能够以TensorFlow, CNTK, 或者Theano 作为后端运行。在此安装以Tensorflow为后端的Keras。\n安装 tensorflow 1.5.0 并不是说Keras 2.2.4版本一定要安装tensorflow 1.5.0，只不过是我之前装好了tensorflow-1.5.0，并在此基础上成功的安装了Keras 2.2.4. 所以 这两个版本在我电脑上是能正常工作的。安装tensorflow 1.5.0 可参考我的另外一篇博文https://blog.nickwhyy.top/post/installtensorflow/\n安装 keras 2.2.4 1 2 3 4 5 6 7 8 9 10 11 12  (tensorflow) C:\\Users\\Admin\u0026gt;pip install keras -U --pre Collecting keras Using cached https://files.pythonhosted.org/packages/5e/10/aa32dad071ce52b5502266b5c659451cfd6ffcbf14e6c8c4f16c0ff5aaab/Keras-2.2.4-py2.py3-none-any.whl Requirement already up-to-date: six\u0026gt;=1.9.0 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from keras) Requirement already up-to-date: numpy\u0026gt;=1.9.1 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from keras) Requirement already up-to-date: h5py in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from keras) Requirement already up-to-date: keras-applications\u0026gt;=1.0.6 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from keras) Requirement already up-to-date: keras-preprocessing\u0026gt;=1.0.5 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from keras) Requirement already up-to-date: pyyaml in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from keras) Requirement already up-to-date: scipy\u0026gt;=0.14 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from keras) Installing collected packages: keras Successfully installed keras-2.2.4   验证是否能运行，进入python，并import keras 模块\n1 2 3 4 5  (tensorflow) C:\\Users\\Admin\u0026gt;python Python 3.5.4 |Continuum Analytics, Inc.| (default, Aug 14 2017, 13:41:13) [MSC v.1900 64 bit (AMD64)] on win32 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import keras Using TensorFlow backend.   如果是类似上面的结果，表面keras安装成功。\n测试 首先，先安装git，然后下载mnist数据集，接着运行例子脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  (tensorflow) C:\\Users\\Admin\u0026gt;conda install git (tensorflow) C:\\Users\\Admin\u0026gt;git clone https://github.com/fchollet/keras.git (tensorflow) C:\\Users\\Admin\u0026gt;cd keras/examples/ (tensorflow) C:\\Users\\Admin\u0026gt;python mnist_mlp.py Using TensorFlow backend. 60000 train samples 10000 test samples _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= dense_1 (Dense) (None, 512) 401920 _________________________________________________________________ dropout_1 (Dropout) (None, 512) 0 _________________________________________________________________ dense_2 (Dense) (None, 512) 262656 _________________________________________________________________ dropout_2 (Dropout) (None, 512) 0 _________________________________________________________________ dense_3 (Dense) (None, 10) 5130 ================================================================= Total params: 669,706 Trainable params: 669,706 Non-trainable params: 0 _________________________________________________________________ Train on 60000 samples, validate on 10000 samples Epoch 1/20 2019-05-17 08:33:14.461356: I C:\\tf_jenkins\\workspace\\rel-win\\M\\windows-gpu\\PY\\35\\tensorflow\\core\\platform\\cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX AVX2 2019-05-17 08:33:14.733043: I C:\\tf_jenkins\\workspace\\rel-win\\M\\windows-gpu\\PY\\35\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1105] Found device 0 with properties: name: GeForce GTX 1060 3GB major: 6 minor: 1 memoryClockRate(GHz): 1.7465 pciBusID: 0000:01:00.0 totalMemory: 3.00GiB freeMemory: 2.42GiB 2019-05-17 08:33:14.737722: I C:\\tf_jenkins\\workspace\\rel-win\\M\\windows-gpu\\PY\\35\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1195] Creating TensorFlow device (/device:GPU:0) -\u0026gt; (device: 0, name: GeForce GTX 1060 3GB, pci bus id: 0000:01:00.0, compute capability: 6.1) 60000/60000 [==============================] - 5s 88us/step - loss: 0.2495 - acc: 0.9227 - val_loss: 0.1002 - val_acc: 0.9672 Epoch 2/20 60000/60000 [==============================] - 3s 45us/step - loss: 0.1028 - acc: 0.9685 - val_loss: 0.0910 - val_acc: 0.9736 Epoch 3/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0750 - acc: 0.9770 - val_loss: 0.0776 - val_acc: 0.9765 Epoch 4/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0594 - acc: 0.9822 - val_loss: 0.0676 - val_acc: 0.9813 Epoch 5/20 60000/60000 [==============================] - 3s 43us/step - loss: 0.0502 - acc: 0.9848 - val_loss: 0.0753 - val_acc: 0.9802 Epoch 6/20 60000/60000 [==============================] - 3s 43us/step - loss: 0.0437 - acc: 0.9866 - val_loss: 0.0826 - val_acc: 0.9785 Epoch 7/20 60000/60000 [==============================] - 3s 43us/step - loss: 0.0397 - acc: 0.9885 - val_loss: 0.0767 - val_acc: 0.9808 Epoch 8/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0343 - acc: 0.9900 - val_loss: 0.0739 - val_acc: 0.9831 Epoch 9/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0310 - acc: 0.9907 - val_loss: 0.0893 - val_acc: 0.9806 Epoch 10/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0306 - acc: 0.9911 - val_loss: 0.0877 - val_acc: 0.9816 Epoch 11/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0280 - acc: 0.9923 - val_loss: 0.0829 - val_acc: 0.9836 Epoch 12/20 60000/60000 [==============================] - 3s 43us/step - loss: 0.0268 - acc: 0.9922 - val_loss: 0.0943 - val_acc: 0.9804 Epoch 13/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0235 - acc: 0.9932 - val_loss: 0.0942 - val_acc: 0.9821 Epoch 14/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0203 - acc: 0.9938 - val_loss: 0.1041 - val_acc: 0.9819 Epoch 15/20 60000/60000 [==============================] - 3s 43us/step - loss: 0.0223 - acc: 0.9937 - val_loss: 0.1115 - val_acc: 0.9808 Epoch 16/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0204 - acc: 0.9945 - val_loss: 0.1017 - val_acc: 0.9835 Epoch 17/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0197 - acc: 0.9950 - val_loss: 0.1142 - val_acc: 0.9829 Epoch 18/20 60000/60000 [==============================] - 3s 43us/step - loss: 0.0206 - acc: 0.9951 - val_loss: 0.1265 - val_acc: 0.9803 Epoch 19/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0196 - acc: 0.9950 - val_loss: 0.1015 - val_acc: 0.9842 Epoch 20/20 60000/60000 [==============================] - 3s 44us/step - loss: 0.0200 - acc: 0.9952 - val_loss: 0.1010 - val_acc: 0.9840 Test loss: 0.10101144369584511 Test accuracy: 0.984   如果出现上述的结果，就表明整个keras是可以正常运行的。如果出现softmax() got an unexpected keyword argument 'axis'这个错误，表明tensorflow 的版本过低，建议升级一下tensorflow，再重新安装keras。\n参考资料  Keras windows安装文档 softmax() error  修订历史  2019-05-17， 初稿  ","permalink":"https://blog.nickwhyy.top/post/installkeras/","tags":["keras"],"title":"Windows 10 安装 Keras 2.2.4"},{"categories":["安装"],"contents":"Why Manjaro? Manjaro 是目前排名第一的一个Linux发行版。（排名数据源于DistroWatch，统计日期2018.03.02，时间段3个月。）Manjaro基于ArchLinux，因此它的主要优势在于比 Debian/Ubuntu更丰富的软件资源。由于其安装非常简单且十分稳定，因此迅速成为DistroWatch排行榜排名第一的Linux发行版。建议从以下网页了解更多有关Manjaro 优势的文章：\n[1] manjaro中文主页\n[2] 7个选择manjaro的理由(en)\n[3] \u0026hellip;\n下载 下载可从中科大镜像站 (http://mirrors.ustc.edu.cn/) 上选择最新版本的manjaro下载。\n制作镜像 建议在windows下采用rufus软件制作镜像，该软件完全免费，操作简单。自从第一次知道有此软件后，每次都采用该软件制作镜像，且制作出来的 镜像十分可靠。另外，也可以在Linux系统下运用dd命令制作镜像。\n安装 安装过程和安装Ubuntu比较接近，也许更简单一点，最主要的就是地区，语言，以及分区的问题。建议选择英文操作系统，不然系统里终端还有文件系统中文在命令行在处理 比较难受。\n制作镜像和安装可参考文章 https://blog.csdn.net/aaazz47/article/details/77416136\n配置系统  更新仓库列表  1  $ sudo pacman-mirrors -g   升级系统  1  $ sudo pacman -Syyu   添加国内源  1  $ sudo gedit /etc/pacman.conf   并在pacman.conf文件中添加如下信息：\n1 2 3 4 5 6  [archlinuxcn] SigLevel = Optional TrustedOnly Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch [arch4edu] SigLevel = Never Server = http://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch   接着执行\n1  $ sudo pacman -Syy \u0026amp;\u0026amp; sudo pacman -S archlinuxcn-keyring   安装包管理系统  1  $ sudo pacman -S yaourt pacaur   安装中文输入法  1 2 3  $ sudo pacman -S fcitx-sogoupinyin $ sudo pacman -S fcitx-im # 建议全部选择，不然后期可能出现bug $ sudo pacman -S fcitx-configtool   设置中文输入法环境变量，否则中文输入法无法启动，终端输入：\n1 2  $ sudo pacman -S vim $ sudo vim ~/.xprofile   将以下文本追加到~/.xprofile文件后面：\n1 2 3  export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=\u0026#34;@im=fcitx\u0026#34;   而后在命令行输入fcitx启动输入法。\n安装 zsh 和 oh-my-zsh  1 2 3 4  $ sudo pacman -S zsh $ sudo pacman -S curl $ sh -c \u0026#34;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026#34; $ chsh -s /bin/zsh   安装 TeXLive 2018  刚开始尝试用texlive镜像的方式安装，结果./install-tl出现莫名错误，遂采用下面的方式：\n1 2  $ sudo pacman -S texlive-core texlive-langchinese texlive-latexextra texlive-publishers $ sudo texhash   安装Foxit Reader 8.0  从官网下载，图形界面安装。\n参考资料 https://alongwy.top/blog/2017/08/20/install-Manjaro/\n","permalink":"https://blog.nickwhyy.top/post/manjaro/","tags":["Manjaro","TeXLive","Linux"],"title":"Manjaro"},{"categories":["安装"],"contents":"前言 PyCurvelab 是对于著名的曲波变换工具 CurveLab 采用 Python 进行封装调用的一 个软件包。目前只支持 Python2，感兴趣的朋友可将其升级至 Python3。其软件虽小，但由于其依赖于许多比较老旧的软件包，所以安装起来特别费劲。另外，网上关于如何 成功安装该软件的教程几乎为零，因此才有此博文。\n依赖软件项 参考官网网站的安装说明和我实际安装的情况，其依赖软件包有：\n  Python -\u0026gt; version 2.3 or above -\u0026gt; http://www.python.org\n  SWIG -\u0026gt; version 1.3 or above -\u0026gt; http://www.swig.org\n  Numpy -\u0026gt; module must be available in your PYTHONPATH environment variable in order to be found by -\u0026gt; version 1.0 or above -\u0026gt; http://numpy.scipy.org/\n  CurveLab -\u0026gt; version 2.0.2 or above -\u0026gt; http://www.curvelet.org\n  FFTW -\u0026gt; version 2.1.5 -\u0026gt; http://www.fftw.org/download.html\n  官方安装说明里只提到了前四个，但由于 CurveLab 的安装依赖于 FFTW(注意，不是FFTW3)。而 FFTW 与 FFTW3 是不兼容的。鉴于未来的发展趋势，有兴趣的朋友可以将 CurveLab 升级到支持 FFTW3 的新版本。\n依赖软件包的前三项都与 Python 相关，最简单的办法就是安装一个Anaconda，基本上就已经装好了上述三个软件包了。下面主要介绍 CurveLab, FFTW, 以及 PyCurvelab.\n安装 FFTW 2.1.5 先下载软件包，链接为 http://www.fftw.org/download.html。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 解压该软件 $ tar -xvf fftw-2.1.5.tar.gz # 进入FFTW-2.1.5软件根目录 $ cd fftw-2.1.5 # configure (非常重要！！！) # CC为C编译器， CFLAGS为C编译器的选项，一定要加上`-fPIC`!!!, --prefix为软件安装路径， LDFLAGS为链接器选项，貌似要加上`-fPIC`，这里不太确定， # 但如果大家安装失败了，就一定要把LDFLAGS=\u0026#34;-fPIC\u0026#34;加上，后面我会解释原因 $ ./configure CC=gcc CFLAGS=\u0026#34;-O3 -fomit-frame-pointer -fno-schedule-insns -fschedule-insns2 -malign-double -fstrict-aliasing -fPIC\u0026#34;\\ --prefix=/home/lloyd/software/fftw-2.1.5 LDFLAGS=\u0026#34;-fPIC\u0026#34; # 编译 $ make # 安装 $ make install   至此， FFTW-2.1.5 的安装就此结束。\n安装 CurveLab 2.1.3 CurveLab 2.1.3 软件只提供给从事于学术研究的人，需要在其网站上注册，链接为 http://www.curvelet.org/register.php，注册之后才可以下载，目前最新的 版本是2.1.3, 貌似是2008年更新的。所以希望有感兴趣的朋友将其改写成支持FFTW3的版本，相信也不是特别难。有精力的同学可以尝试一下。\n解压该软件 1  $ tar -xvf CutveLab-2.1.3.tar.gz   修改makefile.opt文件 makefile.opt文件位于CutveLab-2.1.3的根目录下。\n1 2 3 4 5  # 进入CutveLab-2.1.3软件根目录 $ cd CutveLab-2.1.3 # 打开`makefile.opt`文件 $ gedit makefile.opt   打开后，需要修改内容如下：\n1 2 3 4 5 6 7 8 9 10 11  # ----------------------------machine dependent file MODE = optim # extern library and program variables FFTW_DIR = /home/lloyd/software/fftw-2.1.5 # 修改为自己的FFTW-2.1.5的安装路径 MEX = mex # compiler and linker variable INCLUDES =\t-I${FFTW_DIR}/include # 照此句修改即可 LIBS = -L${FFTW_DIR}/lib -lfftw # 照此句修改即可   由于 PyCurvelab 只需要安装CutveLab的两个组件fdct_wrapping_cpp和fdct3d，下面分别进行描述其安装过程。\n1 2 3 4 5 6 7 8 9  # 进入fdct_wrapping_cpp的src文件夹中 $ cd fdct_wrapping_cpp/src # 编译`libfdct_wrapping.a` $ make # 进入fdct3d的src文件夹中 $ cd fdct3d/src # 编译`libfdct3d.a` $ make   至此，与 CurveLab-2.1.3 的相关的依赖部分安装就此结束。\n安装 PyCurvelab 成功安装好上述依赖项之后，安装PyCurvelab就显得比较容易了。但由于其安装脚本需要调用CurveLab和FFTW的安装目录，因此需要设置两个环境变量。 在当前用户的~/.bashrc中加入如下语句\n1 2 3 4 5  # CurveLab-2.1.3 export FDCT=/home/lloyd/software/CurveLab-2.1.3 # FFTW-2.1.5 export FFTW=/home/lloyd/software/fftw-2.1.5   添加完之后，$ source ~/.bashrc更新一下当前终端的环境变量。\n1 2 3 4 5 6 7 8 9 10 11  # 下载PyCurvelab $ git clone https://github.com/slimgroup/PyCurvelab.git # 进入到PyCurvelab根目录 $ cd PyCurvelab # 编译 $ python2 setup build # 安装 $ sudo python2 setup install # 这里采用root权限是因此，python安装在了系统根目录，如果没有的话则用不需要添加   可能出现的问题 首先，如果严格按照本博文的顺利进行安装的话，应该是不会有任何问题的。但有时候可能您安装的时候并没有看到此博文，可能安装的过程中出现了一些比较奇怪的问题。 最典型的就是这个问题了：\n1 2 3 4 5 6  /usr/bin/ld: /home/lloyd/software/fftw-2.1.5/lib/libfftw.a(fftwnd.o): relocation R_X86_64_PC32 against symbol `stdout@@GLIBC_2.2.5\u0026#39; can not be used when making a shared object; recompile with -fPIC /usr/bin/ld: final link failed: Bad value collect2: error: ld returned 1 exit status error: command \u0026#39;x86_64-linux-gnu-g++\u0026#39; failed with exit status 1   这个问题主要是由于-fPIC选项在一些地方没有添加所导致的。具体该选项的意义大家可以自己查询一下。我们发现，报错信息已经具体的给出了哪个文件(fftwnd.o) 存在问题，因此我们需要查询一下编译fftwnd.o文件的时候我们到底采用了-fPIC选项没有？我们找到/home/lloyd/software/fftw-2.1.5/lib/libfftw.a文件 ，然后对其进行解压，再用命令进行分析。其过程如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  # 进入到libfftw.a的安装路径 $ cd /home/lloyd/software/fftw-2.1.5/lib/ # 解压libfftw.a $ ar -x libfftw.a # 查询是否编译时采用了`-fPIC`选项没有 $ readelf --relocs fftwnd.o | egrep \u0026#39;(GOT|PLT|JU?MP_SLOT)\u0026#39; # 若该语句返回的是空，则没有采用`-fPIC`选项，如果有值，则采用了。 # 下面是采用`-fPIC`选项的显示结果 00000000005a 001d00000004 R_X86_64_PLT32 0000000000000000 fftw_malloc - 4 0000000000b1 001d00000004 R_X86_64_PLT32 0000000000000000 fftw_malloc - 4 0000000000be 001d00000004 R_X86_64_PLT32 0000000000000000 fftw_malloc - 4 0000000000cb 001d00000004 R_X86_64_PLT32 0000000000000000 fftw_malloc - 4 000000000151 001d00000004 R_X86_64_PLT32 0000000000000000 fftw_malloc - 4 0000000001c1 001d00000004 R_X86_64_PLT32 0000000000000000 fftw_malloc - 4 0000000001e2 001f00000004 R_X86_64_PLT32 0000000000000000 memset - 4 00000000028f 002100000004 R_X86_64_PLT32 0000000000000000 fftw_create_plan - 4 000000000315 002200000004 R_X86_64_PLT32 0000000000000000 fftw_destroy_plan - 4 00000000032b 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 000000000642 002400000004 R_X86_64_PLT32 0000000000000360 fftwnd_work_size - 4 00000000069b 002600000004 R_X86_64_PLT32 0000000000000000 fftw_create_plan_speci - 4 000000000705 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 00000000076d 002200000004 R_X86_64_PLT32 0000000000000000 fftw_destroy_plan - 4 000000000780 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 00000000078a 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 0000000007a7 001d00000004 R_X86_64_PLT32 0000000000000000 fftw_malloc - 4 000000000835 002200000004 R_X86_64_PLT32 0000000000000000 fftw_destroy_plan - 4 000000000846 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 000000000855 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 000000000864 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 000000000873 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 000000000882 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 0000000008dd 002900000004 R_X86_64_PLT32 0000000000000000 fwrite - 4 00000000092e 002a00000004 R_X86_64_PLT32 0000000000000000 fprintf - 4 00000000094d 002900000004 R_X86_64_PLT32 0000000000000000 fwrite - 4 00000000096a 002a00000004 R_X86_64_PLT32 0000000000000000 fprintf - 4 0000000009a7 002a00000004 R_X86_64_PLT32 0000000000000000 fprintf - 4 0000000009e6 002b00000004 R_X86_64_PLT32 0000000000000000 fftw_fprint_plan - 4 000000000a1d 002a00000004 R_X86_64_PLT32 0000000000000000 fprintf - 4 000000000a51 002900000004 R_X86_64_PLT32 0000000000000000 fwrite - 4 000000000a63 002d0000002a R_X86_64_REX_GOTP 0000000000000000 stdout - 4 000000000ce3 002f00000004 R_X86_64_PLT32 0000000000000000 fftw - 4 000000000e00 002f00000004 R_X86_64_PLT32 0000000000000000 fftw - 4 000000000ee1 003000000004 R_X86_64_PLT32 0000000000000e30 fftwnd_aux - 4 000000000f2f 002e00000004 R_X86_64_PLT32 0000000000000a80 fftw_buffered - 4 000000000f72 002f00000004 R_X86_64_PLT32 0000000000000000 fftw - 4 000000000fc2 002f00000004 R_X86_64_PLT32 0000000000000000 fftw - 4 00000000100e 002f00000004 R_X86_64_PLT32 0000000000000000 fftw - 4 0000000010f7 003100000004 R_X86_64_PLT32 0000000000001030 fftwnd_aux_howmany - 4 00000000117e 002f00000004 R_X86_64_PLT32 0000000000000000 fftw - 4 000000001224 002e00000004 R_X86_64_PLT32 0000000000000a80 fftw_buffered - 4 0000000012bc 002f00000004 R_X86_64_PLT32 0000000000000000 fftw - 4 000000001356 002f00000004 R_X86_64_PLT32 0000000000000000 fftw - 4 0000000013e7 002f00000004 R_X86_64_PLT32 0000000000000000 fftw - 4 000000001476 003000000004 R_X86_64_PLT32 0000000000000e30 fftwnd_aux - 4 0000000014d7 003100000004 R_X86_64_PLT32 0000000000001030 fftwnd_aux_howmany - 4 000000001517 001d00000004 R_X86_64_PLT32 0000000000000000 fftw_malloc - 4 00000000177a 003400000004 R_X86_64_PLT32 0000000000000000 fftw_gettimeofday_get_ - 4 00000000179f 003400000004 R_X86_64_PLT32 0000000000000000 fftw_gettimeofday_get_ - 4 0000000017cf 003200000004 R_X86_64_PLT32 0000000000001380 fftwnd - 4 0000000017db 003400000004 R_X86_64_PLT32 0000000000000000 fftw_gettimeofday_get_ - 4 0000000017fa 003500000004 R_X86_64_PLT32 0000000000000000 fftw_gettimeofday_time - 4 000000001822 003500000004 R_X86_64_PLT32 0000000000000000 fftw_gettimeofday_time - 4 00000000185e 003500000004 R_X86_64_PLT32 0000000000000000 fftw_gettimeofday_time - 4 000000001886 003500000004 R_X86_64_PLT32 0000000000000000 fftw_gettimeofday_time - 4 000000001992 001b00000004 R_X86_64_PLT32 0000000000000000 fftwnd_create_plan_aux - 4 0000000019d5 002400000004 R_X86_64_PLT32 0000000000000360 fftwnd_work_size - 4 0000000019ef 001e00000004 R_X86_64_PLT32 00000000000001b0 fftwnd_new_plan_array - 4 000000001a02 002000000004 R_X86_64_PLT32 00000000000001f0 fftwnd_create_plans_ge - 4 000000001a17 001e00000004 R_X86_64_PLT32 00000000000001b0 fftwnd_new_plan_array - 4 000000001a3f 002500000004 R_X86_64_PLT32 0000000000000600 fftwnd_create_plans_sp - 4 000000001a7f 002400000004 R_X86_64_PLT32 0000000000000360 fftwnd_work_size - 4 000000001a9b 003300000004 R_X86_64_PLT32 0000000000001540 fftwnd_measure_runtime - 4 000000001ac3 002400000004 R_X86_64_PLT32 0000000000000360 fftwnd_work_size - 4 000000001adf 003300000004 R_X86_64_PLT32 0000000000001540 fftwnd_measure_runtime - 4 000000001b0e 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 000000001b7f 002200000004 R_X86_64_PLT32 0000000000000000 fftw_destroy_plan - 4 000000001b9a 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 000000001bad 002400000004 R_X86_64_PLT32 0000000000000360 fftwnd_work_size - 4 000000001be9 001d00000004 R_X86_64_PLT32 0000000000000000 fftw_malloc - 4 000000001c00 002700000004 R_X86_64_PLT32 00000000000007c0 fftwnd_destroy_plan - 4 000000001c09 001e00000004 R_X86_64_PLT32 00000000000001b0 fftwnd_new_plan_array - 4 000000001c1c 002000000004 R_X86_64_PLT32 00000000000001f0 fftwnd_create_plans_ge - 4 000000001c52 001d00000004 R_X86_64_PLT32 0000000000000000 fftw_malloc - 4 000000001cbd 002200000004 R_X86_64_PLT32 0000000000000000 fftw_destroy_plan - 4 000000001cce 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 000000001d32 002200000004 R_X86_64_PLT32 0000000000000000 fftw_destroy_plan - 4 000000001d4d 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 000000001dba 002200000004 R_X86_64_PLT32 0000000000000000 fftw_destroy_plan - 4 000000001dd0 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 000000001e00 003600000004 R_X86_64_PLT32 0000000000001970 fftwnd_create_plan_spe - 4 000000001e22 003700000004 R_X86_64_PLT32 0000000000001de0 fftw2d_create_plan_spe - 4 000000001e63 003600000004 R_X86_64_PLT32 0000000000001970 fftwnd_create_plan_spe - 4 000000001e7e 003900000004 R_X86_64_PLT32 0000000000001e30 fftw3d_create_plan_spe - 4 000000001ea2 003600000004 R_X86_64_PLT32 0000000000001970 fftwnd_create_plan_spe - 4 000000001ecf 003200000004 R_X86_64_PLT32 0000000000001380 fftwnd - 4 000000000892 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4 000000000a38 002900000004 R_X86_64_PLT32 0000000000000000 fwrite - 4 000000000a6e 002800000004 R_X86_64_PLT32 00000000000008a0 fftwnd_fprint_plan - 4 0000000014fa 002300000004 R_X86_64_PLT32 0000000000000000 fftw_free - 4   参考资料  PyCurveLab官方安装指南 FFTW官方安装指南 错误分析  ","permalink":"https://blog.nickwhyy.top/post/installpycurvelab/","tags":["PyCurvelab","CurveLab","FFTW"],"title":"Linux 安装 PyCurvelab"},{"categories":["安装"],"contents":"前言 本文在本博文之前，已经有很多博文介绍了如何在 Windows10 系统中安装 GPU 版的 tensorflow, 但这些文章存在各种各样的缺陷，完全按照他们的文章，你不一定能 成功安装 tensorflow。基于此，本文旨在用更科学的方式指导大家如何在 Windows 10 系统中安装 GPU 版的 tensorflow，这里安装的不是最新版的，原因下面会提 到。\n前期准备 tensorflow 从发布到现在(写此文的时间)已经经历过多次的升级，而与此同时， NVIDIA 公司开发的 CUDA 以及 cuDNN 这两个依赖项也进行了更新。因此，就导致了 不同版本的 tensorflow 会依赖于不同版本 的 CUDA 和 cuDNN，具体见下表(https://www.tensorflow.org/install/source_windows?hl=zh-cn)。\n这里插播一下我选择安装 tensorflow 1.5.0 的原因，并不是说该版本最稳定，毕竟我也是第一次用 tensorflow ，在此没有话语权。在安装 tensorflow 的时候，我 还不知道有这个表格，我甚至都不知道还要安装 CUDA 和 cuDNN。我上来就知道用 pip install tensorflow-gpu，安装的过程中也没报错，我就天真的以为安装成 功了。接着，用官方提供的简单例子跑了一下，才提示我ImportError: DLL load failed: 找不到指定的模块。. 然后，我搜索了一下问题，发现我没有装 CUDA。 然后我就上 NVIDIA 官网，下载并安装了最新的 CUDA 10。安装，运行例子，还是同样的错误。然后，我搜索了一下问题，发现我没有装 cuDNN。接着，我就上 NVIDIA 官网，下载并安装了 cuDNN。然而，还是没解决该问题。后来经过一次偶然的发现，找到了一个算是半官方的一个用来检测原因的脚本 (https://gist.github.com/mrry/ee5dbcfdd045fa48a27d56664411d41c)，经过测试还知道有不同版本的 tensorflow 会依赖于不同版本 的 CUDA 和 cuDNN 这一 说。但我当时并不知道有上面这个表格，所以只能瞎试了一通。等我发现有这个表格的时候，我电脑里 CUDA 的版本是 9，cuDNN 的版本是 7，因此符合条件的 tensorflow的版本是 1.5.0 - 1.12.0。 我选择了1.5.0版本，主要由于之前成功安装过1.4.0版本。\n各种依赖项在 windows 下安装都比较简单，在此我不再赘述如何具体一步步安装了。不过，我提供一些我觉得讲的比较细致的安装策略供大家参考。\n安装CUDA前请先在设置-\u0026gt;应用中删除所有文件名开头为NVIDIA的软件，并将之前在C盘或其他盘安装的NVIDIA软件目录删除！！！\nCUDA 参见 https://zhuanlan.zhihu.com/p/30528874\ncuDNN 参见 https://zhuanlan.zhihu.com/p/30528874\nVisual studio 2015 参见 https://zhuanlan.zhihu.com/p/30528874\nMSVC 2015 update3 下载地址： https://www.microsoft.com/en-us/download/confirmation.aspx?id=53587\n选择自己对应的版本和系统位数，然后下载，安装即可。\nAnaconda 参见 https://zhuanlan.zhihu.com/p/30528874\n添加 conda 镜像源：https://wiki.seisman.info/python/install-python/ 添加 pip 镜像源：https://wiki.seisman.info/python/install-python/\nCUDA环境变量设置 在Cortana中的搜索框中输入env，并选择编辑账户的环境变量，然后编辑Path变量，并在最后一个路径下方添加下面两个路径：\n C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.0\\bin C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.0\\libnvvp  安装 tensorflow 1.5.0 查看表格我们知道，tensorflow 1.5.0 支持的 Python 版本为 3.5-3.6, 我本人选择的是 3.5.4 的版本。因此，打开 Anaconda Prompt, 输入下面命令\n1  conda create -n tensorflow python=3.5   创建一个 Python 3.5 的环境，然后激活该环境，\n1  activate tensorflow   接着安装 tensorflow 1.5.0,并制定具体的版本号\n1  pip install tensorflow-gou==1.5.0   下面显示了一个成功安装的案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  (tensorflow) C:\\Users\\Admin\u0026gt;pip install tensorflow-gpu==1.5.0 Collecting tensorflow-gpu==1.5.0 Downloading https://files.pythonhosted.org/packages/00/63/068c81e5f50cdbbb30ca4be611979633c5591a7452c6c60ffbf675fac6fe/tensorflow_gpu-1.5.0-cp35-cp35m-win_amd64.whl (82.1MB) 100% |████████████████████████████████| 82.1MB 17kB/s Requirement already satisfied: wheel\u0026gt;=0.26 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from tensorflow-gpu==1.5.0) Requirement already satisfied: six\u0026gt;=1.10.0 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from tensorflow-gpu==1.5.0) Requirement already satisfied: protobuf\u0026gt;=3.4.0 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from tensorflow-gpu==1.5.0) Requirement already satisfied: absl-py\u0026gt;=0.1.6 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from tensorflow-gpu==1.5.0) Collecting tensorflow-tensorboard\u0026lt;1.6.0,\u0026gt;=1.5.0 (from tensorflow-gpu==1.5.0) Downloading https://files.pythonhosted.org/packages/cc/fa/91c06952517b4f1bc075545b062a4112e30cebe558a6b962816cb33efa27/tensorflow_tensorboard-1.5.1-py3-none-any.whl (3.0MB) 100% |████████████████████████████████| 3.0MB 362kB/s Requirement already satisfied: numpy\u0026gt;=1.12.1 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from tensorflow-gpu==1.5.0) Requirement already satisfied: setuptools in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from protobuf\u0026gt;=3.4.0-\u0026gt;tensorflow-gpu==1.5.0) Requirement already satisfied: bleach==1.5.0 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from tensorflow-tensorboard\u0026lt;1.6.0,\u0026gt;=1.5.0-\u0026gt;tensorflow-gpu==1.5.0) Requirement already satisfied: werkzeug\u0026gt;=0.11.10 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from tensorflow-tensorboard\u0026lt;1.6.0,\u0026gt;=1.5.0-\u0026gt;tensorflow-gpu==1.5.0) Requirement already satisfied: html5lib==0.9999999 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from tensorflow-tensorboard\u0026lt;1.6.0,\u0026gt;=1.5.0-\u0026gt;tensorflow-gpu==1.5.0) Requirement already satisfied: markdown\u0026gt;=2.6.8 in g:\\program\\anaconda3\\envs\\tensorflow-gpu-py35\\lib\\site-packages (from tensorflow-tensorboard\u0026lt;1.6.0,\u0026gt;=1.5.0-\u0026gt;tensorflow-gpu==1.5.0) Installing collected packages: tensorflow-tensorboard, tensorflow-gpu Found existing installation: tensorflow-tensorboard 0.4.0 Uninstalling tensorflow-tensorboard-0.4.0: Successfully uninstalled tensorflow-tensorboard-0.4.0 Successfully installed tensorflow-gpu-1.5.0 tensorflow-tensorboard-1.5.1   测试 下面是我测试的情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  (tensorflow) C:\\Users\\Admin\u0026gt;python Python 3.5.4 |Continuum Analytics, Inc.| (default, Aug 14 2017, 13:41:13) [MSC v.1900 64 bit (AMD64)] on win32 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import tensorflow as tf \u0026gt;\u0026gt;\u0026gt; hello = tf.constant(\u0026#34;Hello! Tensorflow\u0026#34;) \u0026gt;\u0026gt;\u0026gt; sess = tf.Session() 2019-05-17 08:29:00.873019: I C:\\tf_jenkins\\workspace\\rel-win\\M\\windows-gpu\\PY\\35\\tensorflow\\core\\platform\\cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX AVX2 2019-05-17 08:29:01.227407: I C:\\tf_jenkins\\workspace\\rel-win\\M\\windows-gpu\\PY\\35\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1105] Found device 0 with properties: name: GeForce GTX 1060 3GB major: 6 minor: 1 memoryClockRate(GHz): 1.7465 pciBusID: 0000:01:00.0 totalMemory: 3.00GiB freeMemory: 2.42GiB 2019-05-17 08:29:01.233815: I C:\\tf_jenkins\\workspace\\rel-win\\M\\windows-gpu\\PY\\35\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1195] Creating TensorFlow device (/device:GPU:0) -\u0026gt; (device: 0, name: GeForce GTX 1060 3GB, pci bus id: 0000:01:00.0, compute capability: 6.1) \u0026gt;\u0026gt;\u0026gt; print(sess.run(hello)) b\u0026#39;Hello! Tensorflow\u0026#39; \u0026gt;\u0026gt;\u0026gt; quit()   参考资料  前期准备安装 Anaconda和pip配置 不同版本tensorflow和其所对应的CUDA和cuDNN  修订历史  2018-11-17， 初稿； 2019-05-17， 增加安装CUDA Computing Toolkit注意事项，增加CUDA环境变量设置，升级Tensorflow为1.5.0；  ","permalink":"https://blog.nickwhyy.top/post/installtensorflow/","tags":["tensorflow"],"title":"Windows 10 安装 tensorflow 1.5.0"},{"categories":["绘图"],"contents":"Why? 科研论文的插图一般为矢量图，但传统的作图软件比如 Matlab 的三维图存在以下缺陷：\n 对于一个大的模型，比如 200x200x15，其输出的 PDF 文件占用大概 20-30 Mb 的空间，用 AI 无法打开； 即便能打开，但由于 matlab 绘制方式的问题， 我们很难对其中的某些切片进行单独操作； 因此，才有本人借助 AI 来绘制一个 3D 矢量图。  How? 首先，我们知道论文中绝大多数的 3D 图都只显示了长方体的三个面（顶面，前面，侧面）。因此，我们只需要通过 Matlab 生成这几个面的 2D image, 剩下的交给 AI 处理即可。这里就直接介绍 AI 中的处理步骤了。\n我们首先介绍如何用 AI 来绘制一个长方体。首先我们在 AI 中绘制一个矩形。\n然后选中该矩形，选择菜单栏的效果\u0026gt;3D\u0026gt;凸出和斜角选项，选择位置\u0026gt;等角-上方，可以 修改一下凸出厚度，其他的可以默认。\n选择确定之后，会发现原来的矩形变成了一个长方体。\n接着，选择菜单栏的对象\u0026gt;扩展外观，选择该对象时，其对象的每一条边都被选中了。\n接着，我们对其进行取消编组，我们就可以对其中的每一个面进行单独选中了。比如我们选中右侧那个面，并将其拖到其他位置，如下图所示：\n接着我们可以通过一个倾斜变换，将其变回一个正常的矩形。参数为变换\u0026gt;倾斜\u0026gt;垂直30°。\n同理，我们也可以其他的面做同样的操作这样就能将其三个面都变回一个正常的矩形了。\n有了上述原理之后，我们只需要设计好长方体的大小，然后就可以根据其变换设计出我们三视图的大小，再反变换回去，就能得到一个完美的长方体了。\n参考资料 https://www.ifeiwu.com/blog/design/1475\n","permalink":"https://blog.nickwhyy.top/post/ai3d/","tags":["AI"],"title":"AI 绘制 3D 矢量图"},{"categories":["绘图"],"contents":"前言 在 Matlab 中调用 GMT 十分简单，前提是 GMT 已安装在自己的电脑下的某一目录中，比如C:\\programs\\gmt5。然后在使用的过程中，只需要在脚本的开头添加 GMT 的执行路径即可。\n绘图 以绘制盐丘速度模型为例，采用在脚本中进行注释的方式来讲解绘图的过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  clear; close all; clc; %% 添加 GMT 可执行二进制文件的路径 addpath(\u0026#39;C:\\programs\\gmt5\\bin\\\u0026#39;); %% 模型的尺寸， n1 = 300; % 深度方向 n2 = 1290; % x 方向 % 简单地读入盐丘速度模型 d1 = readBin(\u0026#39;velocity.dat\u0026#39;,[n1,n2],\u0026#39;float\u0026#39;); %% 归一化速度为 km/s d1 = d1/1000; %% 下面的 y 表示深度方向 xmin = 0; ymin = 0; dx = 0.012192; % km dy = dx; xmax = (n2-1) * 0.012192; ymax = (n1-1) * 0.012192; zmin = 1.5240; % km/s 最小速度 zmax = 4.4806; % km/s 最大速度 reg = 0; %% filename = \u0026#39;velocity.ps\u0026#39;; % 绘图结果文件 xlab = \u0026#39;Distance (km)\u0026#39;; % xlabel ylab = \u0026#39;Depth (km)\u0026#39;; % ylabel R = sprintf(\u0026#39;-R%f/%f/%f/%f\u0026#39;,xmin,xmax,ymin,ymax); psxy = sprintf(\u0026#39;psxy -JX8.46c/-5c %s -P -K \u0026gt; %s\u0026#39;,R,filename); str_X = sprintf(\u0026#39;\u0026#34;%s\u0026#34;\u0026#39;,xlab); str_Y = sprintf(\u0026#39;\u0026#34;%s\u0026#34;\u0026#39;,ylab); %% psbasemap1 = sprintf(\u0026#39;psbasemap -JX8.46c/-5c %s -Bxa+l%s -Bya+l%s -BWN -K -O \u0026gt;\u0026gt; %s\u0026#39;,R,str_X,str_Y,filename); psbasemap2 = sprintf(\u0026#39;psbasemap -JX8.46c/-5c %s -B0 -Bes -K -O \u0026gt;\u0026gt; %s\u0026#39;,R,filename); % https://modules.gmt-china.org/psconvert/ 查看具体的转换文件的指令 psconvert = sprintf(\u0026#39;psconvert %s -E600 -A -TF -Fout -P\u0026#39;, filename); % 将结果转化为多页 PDF 文件，且输出的文件名为 out.pdf % psconvert = sprintf(\u0026#39;psconvert %s -A -Tf -P\u0026#39;, filename); % 将结果转化为单页 PDF 文件, PDF 默认 720 dpi % psconvert = sprintf(\u0026#39;psconvert %s -E600 -A -Tg -P\u0026#39;, filename); % 将结果转化为单页 PNG 文件 % psconvert = sprintf(\u0026#39;psconvert %s -E600 -A -Tt -P\u0026#39;, filename); % 将结果转化为单页 TIFF 文件 grdimage = sprintf(\u0026#39;grdimage -JX8.46c/-5c -P -C -G -O \u0026gt;\u0026gt; %s\u0026#39;,filename); %% head = [xmin xmax ymin ymax zmin zmax reg dx dy]; G = gmt(\u0026#39;wrapgrid\u0026#39;,d1,head); % 将 d1 数据转化为 GMT 的 GRD 格式. cpt = gmt(\u0026#39;grd2cpt -Cjet\u0026#39;, G); % 设置 colormap 为 jet %cpt = gmt(\u0026#39;grd2cpt -Cgray\u0026#39;, G); % 设置 colormap 为 gray gmt(\u0026#39;gmtset FONT_ANNOT_PRIMARY +8p\u0026#39;) % 设置 tic 字号为 8 pt gmt(\u0026#39;gmtset FONT_LABEL +8p\u0026#39;) % 设置 label 字号为 8 pt gmt(psxy); gmt(psbasemap1); gmt(psbasemap2); gmt(grdimage, G, cpt); gmt(psconvert) gmt(\u0026#39;destroy\u0026#39;); % 每次调用完采用该命名终止 GMT 进程。   结果 ","permalink":"https://blog.nickwhyy.top/post/gmtmex/","tags":["GMT","Matlab","绘图"],"title":"Matlab GMT 绘图指南"},{"categories":["绘图"],"contents":"前言 Madagascar 本身自带了绘图功能，但其绘图字体并非主流杂志所描述的 Helvetica 或 Arial 字体，虽然官方给出了关于使用这些字体的 博客， 但实际上，大家仔细比较，会发现其绘出的字体和 Helvetica 或 Arial 字体有很大的差别。\n基于此，我重新写了基于 Matplotlib 的绘图程序，目前的功能比较简单，只支持绘制类似于 Madagascar sfgrey 命令的图片，后面将继续增加更多的绘图 API，以丰富 Madagascar 的绘图效果。\n采用 Matplotlib 绘图有以下好处\n 符合 Geophysics 等主流杂志的图片要求； 解决 Madagascar sfgraph 命令无法绘制 legend 的缺陷； 可直接生成各种图片格式，无需再进行各种转换。 etc  依赖项  需要安装 Madagascar 的 Python API； 需要自行下载并安装 Helvetica 字体。  绘制 Image  下载源程序，并将其安装至 Madagascar 中。 生成一个数据体，并进行绘图。可采用如下示例脚本  1 2 3 4 5 6 7 8 9 10 11 12 13  from rsf.proj import * Flow(\u0026#39;vb\u0026#39;,None,\u0026#39;math n1=101 d1=2 n2=201 d2=2 output=\u0026#34;1500+25*x1\u0026#34;\u0026#39;) # gray image Flow(\u0026#39;vb.png\u0026#39;,\u0026#39;vb\u0026#39;, \u0026#39;gray savefile=$TARGET xlabel=\u0026#34;x (m)\u0026#34; ylabel=\u0026#34;z (m)\u0026#34; cmap=gray \u0026#39;,stdout=-1) # color image Flow(\u0026#39;vb_color.png\u0026#39;,\u0026#39;vb\u0026#39;, \u0026#39;gray savefile=$TARGET xlabel=\u0026#34;x (m)\u0026#34; ylabel=\u0026#34;z (m)\u0026#34; cmap=jet \u0026#39;,stdout=-1) End()   绘图结果： ","permalink":"https://blog.nickwhyy.top/post/rsfpyplot/","tags":["Madagascar","Matplotlib","绘图"],"title":"Madagascar Matplotlib 绘图指南"},{"categories":["软件"],"contents":"Julia SeismicJulia 采用 Julia 语言编写，因此要先安装 Julia. macOS 安装 Julia 非常简单， 直接上官网下载 dmg 镜像文件安装即可。\n安装完成后，可以配置一下环境变量，在${HOME}/.bash_profile 文件末尾添加一行即可：\n1 2  # PATH 后面添加 julia 可执行二进制文件的路径即可 export PATH=\u0026#34;/Applications/Julia-0.6.app/Contents/Resources/julia/bin:$PATH\u0026#34;   Seismic.jl 在任一终端下输入：\n1  $ julia   即可启动 Julia, 安装 Seismic.jl 只需要下面的命令即可：\n1 2  julia\u0026gt; Pkg.add(\u0026#34;Seismic\u0026#34;) julia\u0026gt; Pkg.checkout(\u0026#34;Seismic\u0026#34;)   示例运行 我们以一个简单的二维 FK 滤波为例，具体代码见链接 https://github.com/SeismicJulia/Seismic.jl/blob/master/test/test_SeisFKFilter.jl\n首先找到test_SeisFKFilter.jl文件的目录，然后在该目录下运行\n1  $ julia test_SeisFKFilter.jl   如果没有报错的话，应该出现以下四幅图片，表示安装成功。\n参考资料  https://github.com/SeismicJulia/Seismic.jl  ","permalink":"https://blog.nickwhyy.top/post/seismicjulia/","tags":["SeismicJulia"],"title":"macOS 安装 SeismicJulia"},{"categories":["绘图"],"contents":"前言 采用 Mines JTK 绘图的好处：\n 符合 Geophysics 等主流杂志的图片要求 自动设置图片的各种参数，并根据需求(论文，演讲)生成不同大小的 label 文字 三维绘图能力突出，个人感觉比 MATLAB 要美观。  Mines JTK 基础配置  安装 Mines JTK 安装 Jython  二维图形 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138  import sys import os from java.awt import * from java.io import * from java.lang import * from javax.swing import * from java.util import * # MINES_JTK_LIB 为 edu-mines-jtk-1.1.0.jar 文件的绝对位置，此例中将其设为系统环境变量。 sys.path += [os.environ.get(\u0026#39;MINES_JTK_LIB\u0026#39;)] from edu.mines.jtk.awt import * from edu.mines.jtk.dsp import * from edu.mines.jtk.io import * from edu.mines.jtk.interp import * from edu.mines.jtk.mosaic import * from edu.mines.jtk.util import * from edu.mines.jtk.util.ArrayMath import * pngDir = None pngDir = \u0026#34;./png/\u0026#34; seismicDir = \u0026#34;./data/\u0026#34; fxfile = \u0026#34;vel2\u0026#34; f1,f2 = 0,0 d1,d2 = 0.012192,0.012192 n1,n2 = 300,1290 s1 = Sampling(n1,d1,f1) s2 = Sampling(n2,d2,f2) def main(args): greyPlot() #colorPlot() def greyPlot(): fx = readImage(fxfile) # 绘制灰度图 plot(fx,cmap=gray,cmin=1.500,cmax=4.500,cint=0.500,label=\u0026#34;Velocity (km/s)\u0026#34;,png=\u0026#34;vel-grey\u0026#34;) # 绘制彩色图 plot(fx,cmap=jet,cmin=1.500,cmax=4.500,cint=0.500,label=\u0026#34;Velocity (km/s)\u0026#34;,png=\u0026#34;vel-jet\u0026#34;) ############################################################################# # graphics gray = ColorMap.GRAY jet = ColorMap.JET def jetFill(alpha): return ColorMap.setAlpha(ColorMap.JET,alpha) def jetFillExceptMin(alpha): a = fillfloat(alpha,256) a[0] = 0.0 return ColorMap.setAlpha(ColorMap.JET,a) def jetRamp(alpha): return ColorMap.setAlpha(ColorMap.HUE_BLUE_TO_RED,rampfloat(0.0,alpha/256,256)) def grayRamp(alpha): return ColorMap.setAlpha(ColorMap.GRAY,rampfloat(0.0,alpha/256,256)) def plot(f,g=None,v1=None,v2=None, cmap=None,cmin=None,cmax=None,cint=None, label=None,neareast=False,png=None): sp = SimplePlot(SimplePlot.Origin.UPPER_LEFT) sp.setVInterval(1.000) sp.setHInterval(2.000) sp.setHLabel(\u0026#34;Distance (km)\u0026#34;) sp.setVLabel(\u0026#34;Depth (km)\u0026#34;) pxv = sp.addPixels(s1,s2,f) sp.setVLimits(f1,f1+n1*d1) sp.setHLimits(f2,f2+n2*d2) if cmap: pxv.setColorModel(cmap) else: pxv.setColorModel(ColorMap.JET) #pxv.setInterpolation(PixelsView.Interpolation.NEAREST) if g: pxv.setClips(-1,1) else: if cmin and cmax: pxv.setClips(cmin,cmax) if g: pv = sp.addPixels(s1,s2,g) pv.setInterpolation(PixelsView.Interpolation.NEAREST) pv.setColorModel(cmap) if cmin and cmax: pv.setClips(cmin,cmax) cb = sp.addColorBar() if cint: cb.setInterval(cint) if label: cb.setLabel(label) if (v1 and v2): x1 = zerofloat(2) x2 = zerofloat(2) dx1,dx2 = 6, 14 scale = 4 for i2 in range(0,n2,dx2): for i1 in range(0,n1,dx1): x2[0] = (i2-v2[i2][i1]*scale)*d2+f2 x2[1] = (i2+v2[i2][i1]*scale)*d2+f2 x1[0] = (i1-v1[i2][i1]*scale)*d1+f1 x1[1] = (i1+v1[i2][i1]*scale)*d1+f1 pvu = sp.addPoints(x1,x2) pvu.setLineWidth(4) pvu.setLineColor(Color.CYAN) sp.plotPanel.setColorBarWidthMinimum(100) sp.setSize(1050,700) #for f3d sp.setFontSize(30) if pngDir and png: sp.paintToPng(300,3.333,pngDir+png+\u0026#34;.png\u0026#34;) ############################################################################# # utilities def gain(x): g = mul(x,x) ref = RecursiveExponentialFilter(100.0) ref.apply1(g,g) y = zerofloat(n1,n2) div(x,sqrt(g),y) return y def readImage(name): fileName = seismicDir+name+\u0026#34;.dat\u0026#34; # this data must be xdr_float format. n1,n2 = s1.count,s2.count image = zerofloat(n1,n2) ais = ArrayInputStream(fileName) ais.readFloats(image) ais.close() return image ############################################################################# # Run the function main on the Swing thread import sys class _RunMain(Runnable): def __init__(self,main): self.main = main def run(self): self.main(sys.argv) def run(main): SwingUtilities.invokeLater(_RunMain(main)) run(main)   参考资料  https://github.com/xinwucwp/sos http://inside.mines.edu/~dhale/notebook.html#2009_07_05  ","permalink":"https://blog.nickwhyy.top/post/jtkplot/","tags":["MinesJTK","绘图"],"title":"MinesJTK 绘图指南"},{"categories":["地震学软件"],"contents":"下载源码 1  \u0026gt; git clone https://github.com/MinesJTK/jtk.git   编译 进入jtk\\目录，在命令提示符中输入\n1  \u0026gt; gradlew   待操作完成后，若在core\\build\\libs\\下发现有edu-mines-jtk-x.x.x.jar文件，表示编译成功\n测试 进入jtk\\目录，在命令提示符中输入\n1 2 3  \u0026gt; gradlew test BUILD SUCCESSFUL in 12m 15s.apache.org/maven2/org/jacoco/org.jacoco.agent/0.8.0/org.jacoco.agent-0.8.0.jar 8 actionable tasks: 5 executed, 3 up-to-date2/org/python/jython-standalone/2.7.0/jython-standalone-2.7.0.pom   若最终结果如图中所示，则表示单元测试成功。\n示例程序  示例一(Java)  1  \u0026gt; gradlew run -P demo=mosaic.PlotFrameDemo   其结果为下图所示 示例二(Jython)  1  \u0026gt; gradlew run -P demo=mosaic/PlotFrameDemo.py   其结果为下图所示 参考 https://github.com/MinesJTK/jtk\n","permalink":"https://blog.nickwhyy.top/post/jtkinstall/","tags":["MinesJTK"],"title":"Windows 下 MinesJTK 安装指南"},{"categories":["绘图"],"contents":"本博文的示例采用 SConstruct 脚本来书写，关于如何采用 SConstruct 写 Seismic Unix 脚本详见另一篇博文 http://nickwhyy.top/su-scons-together/ 。\n二维数据 灰度图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  from rsf.proj import * import rsf.suproj as sp sp.Flow(\u0026#39;velocity.eps\u0026#39;,\u0026#39;velocity.dat\u0026#39;, \u0026#39;\u0026#39;\u0026#39; psimage n1=300 d1=12.192 d2=12.192 d1num=1000 f1num=0 n1tic=1 d2num=2000 f2num=0 n2tic=1 width=3.33 height=1.6 label2=\u0026#39;Distance (m)\u0026#39; label1=\u0026#39;Depth (m)\u0026#39; labelsize=8 legend=1 lstyle=vertright units=\u0026#39;Velocity (m/s)\u0026#39; lwidth=0.1 lheight=1.6 \u0026#39;\u0026#39;\u0026#39;) End()   彩色图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  from rsf.proj import * import rsf.suproj as sp sp.Flow(\u0026#39;vel-color.eps\u0026#39;,\u0026#39;velocity.dat\u0026#39;, \u0026#39;\u0026#39;\u0026#39; psimage n1=300 d1=12.192 d2=12.192 d1num=1000 f1num=0 n1tic=1 d2num=2000 f2num=0 n2tic=1 width=3.33 height=1.6 label2=\u0026#39;Distance (m)\u0026#39; label1=\u0026#39;Depth (m)\u0026#39; labelsize=8 legend=1 lstyle=vertright units=\u0026#39;Velocity (m/s)\u0026#39; lwidth=0.1 lheight=1.6 threecolor=1 wrgb=1.0,0,0 grgb=1.0,1.0,1.0 brgb=0,0,1.0 \u0026#39;\u0026#39;\u0026#39;) End()   波形图 1 2 3 4 5 6 7  sp.Flow(\u0026#39;dn.eps\u0026#39;,\u0026#39;dn.bin\u0026#39;, \u0026#39;\u0026#39;\u0026#39; pswigb n1=501 d1=0.002 d2=1 wbox=3.33 hbox=4 label2=\u0026#39;Trace #\u0026#39; label1=\u0026#39;Time (s)\u0026#39; labelsize=8 \u0026#39;\u0026#39;\u0026#39;)   三维数据 灰度图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  sp.Flow(\u0026#39;salt3d_dat_txy.eps\u0026#39;,\u0026#39;salt3d_dat_txy.TRC\u0026#39;, \u0026#39;\u0026#39;\u0026#39; pscube n1=501 n2=250 n3=201 d1=0.008 f1=0 d2=0.04 f2=0 d3=0.04 f3=0 f3num=0.5 d3num=2 n3tic=1 size1=4 size2=3.33 size3=1.5 label1=\u0026#39;Time (s)\u0026#39; label2=\u0026#39;x (km)\u0026#39; label3=\u0026#39;y (km)\u0026#39; labelsize=8 perc=98 bps=24 legend=1 lstyle=vertright units=\u0026#39;Amplitude\u0026#39; lwidth=0.1 lheight=4.0 \u0026#39;\u0026#39;\u0026#39;)   彩色图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  sp.Flow(\u0026#39;salt3d_vel_zxy.eps\u0026#39;,\u0026#39;salt3d_vel_zxy.TRC\u0026#39;, \u0026#39;\u0026#39;\u0026#39; pscube n1=201 n2=250 n3=250 d1=0.04 f1=0 d2=0.04 f2=0 d3=0.04 f3=0 f3num=0.5 d3num=2 n3tic=1 size1=4 size2=3.33 size3=1.5 label1=\u0026#39;Depth (km)\u0026#39; label2=\u0026#39;x (km)\u0026#39; label3=\u0026#39;y (km)\u0026#39; labelsize=8 perc=98 bps=24 legend=1 lstyle=vertright units=\u0026#39;Amplitude\u0026#39; lwidth=0.1 lheight=4.0 wrgb=0.0,0.0,1.0 grgb=1.0,0.0,0.0 brgb=1.0,1.0,1.0 bps=24 \u0026#39;\u0026#39;\u0026#39;)   参考资料 http://blog.sciencenet.cn/blog-2834901-1084725.html\n","permalink":"https://blog.nickwhyy.top/post/suplot/","tags":["SU"],"title":"Seismic Unix 绘图指南"},{"categories":["安装"],"contents":"简介 Windows Subsystem for Linux (WSL) 是 Win10 系统的新功能，其主要特性是在 Windows 下包含一个 Linux 子系统，方便开发人员不用切换系统就能开发一些软件，功能等。\n安装 WSL 其安装过程比较简单，打开cmd终端，然后输入\n1  lxrun /install   之后会自动进行下载一个比较小的 Linux 发行版的安装文件 (默认是 Ubuntu)，然后按照提示的操作一步步执行就安装完毕。整个安装过程不超过 5 分钟。\n使用 使用 WSL 可直接在 Win10 的搜索框中输入 bash, 最上面应该会显示一个 Ubuntu 的 logo 的 应用 Bash on Ubuntu on Windows，点开即可正常使用。\n图形界面 可采用 Xming 作为显示来展示 WSL 需要图形界面显示的内容。然后在${HOME}/.bashrc中设置DISPLAY=:0即可。设置如下\n1 2  # DISPLAY export DISPLAY=:0   迁移文件系统 WSL 的文件系统位于 C 盘，当安装的软件越来越多时，会占用大量的 C 盘空间。这对于使用 SSD 的同学或者C 盘空间本身很小的同学十分不便，因此很多人都存在将 WSL rootfs 迁移至系统其它路径的需求。该问题官方正在研究一种稳定可行的方案，具体进展详见 https://github.com/Microsoft/WSL/issues/449. 目前一个比较好的解决方案是采用DDoSolitary开发的 LxRunOffline. 其解决方案如下：\n  下载 LxRunOffline 软件 链接为：https://github.com/DDoSolitary/LxRunOffline/releases\n  解压，并在该目录下打开命令提示符，输入如下代码\n  1 2 3 4 5  # 显示当前的 Distribution 名称 \u0026gt; LxRunOffline list Legacy # 移动该 Distribution \u0026gt; LxRunOffline move -n Legacy -d D:\\wsl\\legacy   上述命令将整个 WSL 的 rootfs 移动至 D:\\wsl\\legacy 文件夹下。\ncheck 能否正常使用，按照使用一节提示的操作进行即可。  效率提高 wsl-terminal 是一款用来快速在当前目录下打开 WSL 的终端，其使用步骤详见官方说明。\n参考  https://github.com/DDoSolitary/LxRunOffline https://github.com/Microsoft/WSL/issues/449 https://github.com/goreliu/wsl-terminal/releases https://www.howtogeek.com/261575/how-to-run-graphical-linux-desktop-applications-from-windows-10s-bash-shell/  ","permalink":"https://blog.nickwhyy.top/post/wsl/","tags":["WSL"],"title":"Windows Subsystem for Linux 安装及使用"},{"categories":["地震学"],"contents":"生成界面坐标文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 界面1 # x z, 第一列为x坐标， 第二列为z坐标 Flow(\u0026#39;bvel1.asc\u0026#39;,None, \u0026#39;\u0026#39;\u0026#39; echo 0 700 500 900 1000 1000 1500 900 2000 700 2500 900 3000 1000 3500 900 4000 700 n1=2 n2=9 in=$TARGET data_format=ascii_float \u0026#39;\u0026#39;\u0026#39;)   可以按照上述，生成多个界面的坐标信息文件\n将界面坐标进行插值 1 2 3 4 5 6  # n1 表示x轴 Flow(\u0026#39;lay1\u0026#39;,\u0026#39;bvel1.asc\u0026#39;, \u0026#39;\u0026#39;\u0026#39; dd form=native | spline n1=401 d1=10 o1=0 \u0026#39;\u0026#39;\u0026#39;)   插值的目的是为了得到一个规则网格的界面坐标信息\n建模 1 2 3 4 5 6 7 8 9 10 11  # 建模前首先将多个界面信息文件拼接成一个总的文件 Flow(\u0026#39;lays\u0026#39;,\u0026#39;lay1 lay2\u0026#39;,\u0026#39;cat axis=2 ${SOURCES[1:2]}\u0026#39;) # 采用sfunif2来建模，和su中的unif2类似 nz = 201; dz = 10; oz = 0 # spatial sampling in z Flow(\u0026#39;vel1\u0026#39;,\u0026#39;lays\u0026#39;, \u0026#39;\u0026#39;\u0026#39; unif2 n1=%dd1=%go1=%gv00=2000,2500,3000 | put label1=Depth unit1=m label2=Distance unit2=m label=Velocity unit=m/s \u0026#39;\u0026#39;\u0026#39; % (nz,dz,oz) )   将上述各部分合并成一个文件，并进行适当的优化，新的脚本如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  # velocity model construction nz = 201; dz = 10; oz = 0 # spatial sampling in z nx = 401; dx = 10; ox = 0 # spatial sampling in x # 注意，每个界面至少有4个坐标，与三次样条插值sfspline有关 layers = ( ((0,700),(500,900),(1000,1000),(1500,900),(2000,700),(2500,900),(3000,1000),(3500,900),(4000,700)), # 第一个界面 ((0,1500),(1000,1500),(2000,1500),(3000,1500),(4000, 1500)) # 第二个界面 ) def arr2str(array,sep=\u0026#39; \u0026#39;): return string.join(map(str,array),sep) nlays = len(layers) # 将生成界面坐标文件与插值合并 for i in range(nlays): inp = \u0026#39;inp%d\u0026#39; % i Flow(inp+\u0026#39;.asc\u0026#39;,None, \u0026#39;\u0026#39;\u0026#39; echo %sin=$TARGET data_format=ascii_float n1=2 n2=%d\u0026#39;\u0026#39;\u0026#39; % \\ (\u0026#39; \u0026#39;.join(map(lambda x: \u0026#39; \u0026#39;.join(map(str,x)), layers[i])),len(layers[i]))) lay = \u0026#39;lay%d\u0026#39; % i Flow(lay,inp+\u0026#39;.asc\u0026#39;,\u0026#39;dd form=native | spline n1=%dd1=%go1=%g\u0026#39; %(nx,dx,ox)) Flow(\u0026#39;lays\u0026#39;,\u0026#39;lay0 lay1 \u0026#39;, \u0026#39;cat axis=2 ${SOURCES[1:2]}\u0026#39;) Flow(\u0026#39;vel\u0026#39;,\u0026#39;lays\u0026#39;, \u0026#39;\u0026#39;\u0026#39; unif2 n1=%dd1=%go1=%gv00=1500,2000 | put label1=Depth unit1=m label2=Distance unit2=m label=Velocity unit=m/s \u0026#39;\u0026#39;\u0026#39; % (nz,dz,oz) )   运行上述脚本，得到的结果图如下：\n参考  http://www.ahay.org/RSF/book/rsf/school2015/modmig.html https://github.com/ahay/src/blob/master/book/tccs/nmodeblend/synth/SConstruct  修订历史  2018-05-21：初稿； 2018-12-18：修复文档中的错误信息。  ","permalink":"https://blog.nickwhyy.top/post/rsf-unif2/","tags":["Madagascar"],"title":"Madagascar 建立速度模型流程"},{"categories":["编程"],"contents":"配置 安装含Matlab API的Madagascar过程详见Madagascar安装\n写.rsf文件 下面的matlab程序提供了一个使用linear_events来合成一个水平地震事件的例子\n1 2 3 4 5 6 7 8 9 10  functionLinear(out)% linear_events.m : downloaded from http://seismic-lab.physics.ualberta.ca/ d1 = linear_events(0.004,40,2,[0:10:10*79],1,0,1,2,2,2013); % create header rsf_create(out,size(d1)\u0026#39;); % write data rsf_write(d1,out,\u0026#39;same\u0026#39;);   在SConstruct中的调用如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  from rsf.proj import* from rsf.prog import RSFROOT ######################################################################## # INITIALIZATION ######################################################################## matlab = WhereIs(\u0026#39;matlab\u0026#39;) matROOT = \u0026#39;./\u0026#39; matfun = \u0026#39;Linear\u0026#39; matlabpath = os.environ.get(\u0026#39;MATLABPATH\u0026#39;,os.path.join(RSFROOT,\u0026#39;lib\u0026#39;)) if not matlab: sys.stderr.write(\u0026#39;\\nCannot find Matlab.\\n\u0026#39;) sys.exit(1) Flow(\u0026#39;d\u0026#39;,[os.path.join(matROOT,matfun+\u0026#39;.m\u0026#39;)], \u0026#39;\u0026#39;\u0026#39;MATLABPATH=%(matlabpath)s%(matlab)s-nosplash -nojvm -r \u0026#34;addpath %(matROOT)s;%(matfun)s(\u0026#39;${TARGET}\u0026#39;);quit\u0026#34; \u0026#39;\u0026#39;\u0026#39;%vars(),stdin=0,stdout=-1) End()   运行上述脚本SConstruct后生成的数据如下图所示\n读.rsf文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  functionLinearWrite(in,out)% read in size, delta of input header % size: [n1 n2 n3 ...] % delta: [d1 d2 d3 ...] [sz, delta] = rsf_read_header(in); % allocate space d1 = zeros(sz); % read in input data rsf_read(d1,in,\u0026#39;same\u0026#39;); % generate another linear event d2 = linear_events(0.004,40,2,[0:10:10*79],0.5,0.001,1,2,2,2013); d = d1 + d2; % create header rsf_create(out,in); % write data rsf_write(d,out,\u0026#39;same\u0026#39;);   对应的SConstruct如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  from rsf.proj import* from rsf.prog import RSFROOT ######################################################################## # INITIALIZATION ######################################################################## matlab = WhereIs(\u0026#39;matlab\u0026#39;) matROOT = \u0026#39;./\u0026#39; matfun = \u0026#39;LinearWrite\u0026#39; matlabpath = os.environ.get(\u0026#39;MATLABPATH\u0026#39;,os.path.join(RSFROOT,\u0026#39;lib\u0026#39;)) if not matlab: sys.stderr.write(\u0026#39;\\nCannot find Matlab.\\n\u0026#39;) sys.exit(1) Flow(\u0026#39;d2\u0026#39;,[os.path.join(matROOT,matfun+\u0026#39;.m\u0026#39;),\u0026#39;d\u0026#39;], \u0026#39;\u0026#39;\u0026#39;MATLABPATH=%(matlabpath)s%(matlab)s-nosplash -nojvm -r \u0026#34;addpath %(matROOT)s;%(matfun)s(\u0026#39;${SOURCES[1]}\u0026#39;,\u0026#39;${TARGET}\u0026#39;);quit\u0026#34; \u0026#39;\u0026#39;\u0026#39;%vars(),stdin=0,stdout=-1) Plot(\u0026#39;d2\u0026#39;,\u0026#39;grey wanttitle=n\u0026#39;) End()   生成的数据如下图所示\n函数参数处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  % LinearPar函数多了一些数值型的参数dt,f0,tmax functionLinearPar(in,out,dt,f0,tmax)% read in size, delta of input header % size: [n1 n2 n3 ...] % delta: [d1 d2 d3 ...] [sz, delta] = rsf_read_header(in); % allocate space d1 = zeros(sz); % read in input data rsf_read(d1,in,\u0026#39;same\u0026#39;); % generate another linear event d2 = linear_events(dt,f0,tmax,[0:10:10*79],0.5,0.001,1,2,2,2013); d = d1 + d2; % create header rsf_create(out,in); % write data rsf_write(d,out,\u0026#39;same\u0026#39;);   对应的SConstruct脚本如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  from rsf.proj import* from rsf.prog import RSFROOT ######################################################################## # INITIALIZATION ######################################################################## matlab = WhereIs(\u0026#39;matlab\u0026#39;) matROOT = \u0026#39;./\u0026#39; matfun = \u0026#39;LinearPar\u0026#39; matlabpath = os.environ.get(\u0026#39;MATLABPATH\u0026#39;,os.path.join(RSFROOT,\u0026#39;lib\u0026#39;)) if not matlab: sys.stderr.write(\u0026#39;\\nCannot find Matlab.\\n\u0026#39;) sys.exit(1) dt = 0.004 f0 = 40 tmax = 2 Flow(\u0026#39;d3\u0026#39;,[os.path.join(matROOT,matfun+\u0026#39;.m\u0026#39;),\u0026#39;d\u0026#39;], \u0026#39;\u0026#39;\u0026#39;MATLABPATH=%(matlabpath)s%(matlab)s-nosplash -nojvm -r \u0026#34;addpath %(matROOT)s;%(matfun)s(\u0026#39;${SOURCES[1]}\u0026#39;,\u0026#39;${TARGET}\u0026#39;,%(dt)g,%(f0)g,%(tmax)g);quit\u0026#34; \u0026#39;\u0026#39;\u0026#39;%vars(),stdin=0,stdout=-1) End()   参考 https://github.com/ahay/src/blob/master/book/tccs/emdpf/\n","permalink":"https://blog.nickwhyy.top/post/2018-05-20-rsf-matlab/","tags":["Matlab","Madagascar"],"title":"Madagascar Matlab 混合编程"},{"categories":["绘图"],"contents":"绘图基础 首先，需要知道的是matlab三维图的默认坐标轴的位置：面向大家的是 y-z平面，侧面是 x-z 平面，顶底是 x-y 平面。如下图所示\n通过该图，我们能进一步了解到其绘图坐标系的原点的位置，如下图所示 绘制四维图需要采用slice命令，slice命令的两个基本用法如下\n1 2 3  % V 是数据体，sx,sy,sz分别为x,y,z方向的切片，X,Y,Z 为坐标值。 slice(V,sx,sy,sz) % 此命令采用索引绘图，绘图出来的坐标轴的值为索引值 slice(X,Y,Z,V,sx,sy,sz) % 该命令绘制出来的坐标轴的值为真实坐标值。   我们这里选择第二种方式来绘图，以便清楚地解释数据的物理意义。\n生成三维坐标网格数据。 由于地震勘探数据的特殊物理意义，Z坐标轴一般为深度或者时间，因此，如果原始数据并非深度或时间，可采用permute函数将数据转换成第三维为深度或时间的数据。\n1 2  % 假设原始数据的size为 [nz, nx, ny] = size(T); T = permute(T, [3 2 1]); % 将第三维和第一维互换   对数据进行上述预处理后，我们开始生成网格数据。生成网格数据的命令为meshgrid。\n1 2 3 4  x = linspace(0,1,nx); y = linspace(0,2,ny); z = linspace(0,3,nz); [X Y Z] = meshgrid(x, y, z);   若采用上述命令来生成[X Y Z], 则\n1 2 3  \u0026gt; size(X) ans [ny, nx, nz]   可以发现其第三维的维度没变，而前两维的维度互换。而X的维度要与实际数据的维度相对应，因此，在实际操作中，若采用[X Y Z] = meshgrid(x, y, z);的方式来生成网格数据，那么实际数据的维度应为[ny nx nz].\n绘图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  x = (0:nx-1)*dx; y = (0:ny-1)*dy; z = (0:nz-1)*dz; [X, Y, Z] = meshgrid(x,y,z); figure; slice(X,Y,Z,vel,0,0,8); % vel 为绘图数据，其维度为[ny nx nz]; colormap(jet); shading flat; xlabel(\u0026#39;x (km)\u0026#39;); ylabel(\u0026#39;y (km)\u0026#39;); zlabel(\u0026#39;z (km)\u0026#39;); set(gca,\u0026#39;ZDir\u0026#39;,\u0026#39;reverse\u0026#39;); % Z轴反转，常用于地学数据 set(gca,\u0026#39;YDir\u0026#39;,\u0026#39;reverse\u0026#39;);   完善细节 图3的主要缺陷是x轴与y轴的label位置未与坐标轴平行，调整的方式为，可将label进行一定程度地旋转，使其与坐标轴平行。\n1 2 3 4  x1 = xlabel(\u0026#39;x (km)\u0026#39;); y1 = ylabel(\u0026#39;y (km)\u0026#39;); set(x1,\u0026#39;Rotation\u0026#39;,15); set(y1,\u0026#39;Rotation\u0026#39;,-20);   旋转之后的效果见图4\nReference: http://blog.sina.com.cn/s/blog_618af1950100eyjn.html\nhttp://muchong.com/html/201206/4636839.html\n","permalink":"https://blog.nickwhyy.top/post/matlab4d/","tags":["Matlab"],"title":"Matlab 绘制4D数据"},{"categories":["编程"],"contents":"首先我们先针对一些列的散点(x1,y1)进行拟合(x1,y1均为矢量)。其三次样条拟合的结果如下图所示，并将 其拟合结果存为fitresult。\nmatlab 对数据做完三次样条拟合后的数据为cfit类型，是一种拟合的数据体，虽然此数据体可直接通过 plot函数绘制出来，但往往我们需要对其中的数据进行进一步的操作。因此，需要对cfit类型进行一定的 了解。通过一次简单地试错，我们发现cfit类型的数据有一个子参数p.\n1 2 3 4  \u0026gt;\u0026gt; fitresult.q 错误使用 cfit/subsref (line 18) The name \u0026#39;q\u0026#39; is not a coefficient or a problem parameter. You can only use dot notation to access the coefficients and problem parameters of a cfit or sfit, e.g., \u0026#39;f.p\u0026#39;.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026gt;\u0026gt; class(fitresult.p) ans = struct \u0026gt;\u0026gt; fitresult.p ans = form: \u0026#39;pp\u0026#39; breaks: [1x84 double] coefs: [83x4 double] pieces: 83 order: 4 dim: 1   上述实验表明cfit数据的本质为一个problem，因而其含有参数p. 其p参数是一个struct,struct 含有form等参数，用于指定所采用的拟合函数的类型，以及对应的一些系数等。对于三次样条拟合，我们可 通过函数ppval来计算出给定一个自变量xq对应的函数值yq.\n1 2  xq = linspace(0,100,500); yq = ppval(fitresult.p, xq);   xq 和 yq 即为原数据(x1,y1)进行三次样条拟合后的数据集。\n","permalink":"https://blog.nickwhyy.top/post/2018-05-14-matlabfit/","tags":["Matlab"],"title":"Matlab 拟合数据体类型解读"},{"categories":["绘图"],"contents":"通常情况下，matlab绘出的色标主要存在两个问题：1色标的宽度太宽；2色标的高度太高。为了绘制更美观的图像，这里深入研究了一下色标的大小调整方法。\n1.如何修改色标的大小，以及控制色标在图片中的位置？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  fig=figure; fig.Units=\u0026#39;inch\u0026#39;; fig.Position=[4 4 3.5 4]; imagesc(linspace(0,1,201),linspace(0,250,600),Mask), axis ij set(gca,\u0026#39;xaxislocation\u0026#39;,\u0026#39;top\u0026#39;,\u0026#39;Fontsize\u0026#39;,10,... \u0026#39;TickDir\u0026#39;,\u0026#39;out\u0026#39;) ax=gca; ax.Position = [0.2 0.1 0.65 0.75] %控制坐标轴的位置，以及长宽比 c = colorbar; c.Position = [0.88 0.22 0.025 0.5]; %控制色标的位置以及长宽比 colormap(jet); xlabel(\u0026#39;Normalized Wavenumber\u0026#39;,\u0026#39;FontSize\u0026#39;,10),ylabel(\u0026#39;Frequency (Hz)\u0026#39;,\u0026#39;FontSize\u0026#39;,10); % set(gcf,\u0026#39;PaperPosition\u0026#39;,[0 0 10 12]); print -r300 -dtiff spectra.tif   2.如何控制色标的标度，这样绘制多幅图片的时候能保证是同一个色标。 查询色标的范围可以单独使用\n1  cc = caxis; % 查询当前图片的色标范围并保存为cc变量   在绘图语句中加入下面这句即可。\n1  caxis(cc); %将上述存储的cc变量作为这副图片的色标范围，达到两幅图色标一致的目的。   3.很多时候我们需要进行多图展示，但只有其中的几幅图需要colorbar。如果直接用matlab来绘制多图的话，很难控制每幅图的坐标轴长度都一致。同理，绘制单幅图也很难保证带色标图的坐标轴的长度与不带色标图的坐标长度一致。\n对于这种情况，我的建议是绘制单幅图，优势有很多。单幅图可反复多次利用，也用来拼接成多幅，也可以单幅单独使用，十分便利。\n在保证单幅图的情况下，我们需要保证每幅图的大小是一致的，这个通过 1 中给出的控制图的大小的语句即可完成。接下来需要保证是带色标的图的色标保持一致，这个通过 2 中给出的例子即可完成。接下来就是绘图的时候不要加色标，每幅图都单独成图，色标一致即可，但不加色标。最后，我们再单独生成一个色标范围与各图保持一致的色标即可。可采用如下命令\n1 2 3 4 5 6 7 8  fig=figure; fig.Units=\u0026#39;inch\u0026#39;; fig.Position = [4 4 1.0 4]; axis off colormap(jet) % 色标颜色方案与前面图保持一致，很重要！！！ c = colorbar; c.Position = [0.53 0.28 0.10 0.5] % 控制色标的位置以及长宽比 caxis(cc) % 与前面保持一致，保证色标值与前面相吻合，也和数据相吻合。   ","permalink":"https://blog.nickwhyy.top/post/2018-05-09-matlabcolorbar/","tags":["Matlab","colorbar"],"title":"Matlab如何绘制美观的colorbar"},{"categories":["算法"],"contents":"快速选择算法通常用来在未排序的数组中寻找第k小/第k大的元素。其方法类似于快速排序。快速选择和快速排序都是Tony Hoare发明的，因此也称为Hoare\u0026rsquo;s algorithm。\n下面是Madagascar中对快速选择算法的实现部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  float sf_quantile(int q /* quantile */, int n /* array length */, float* a /* array [n] */) /*\u0026lt; find quantile (caution: a is changed) \u0026gt;*/ { float *i, *j, ak, *low, *hi, buf, *k; low=a; hi=a+n-1; k=a+q; while (low\u0026lt;hi) { ak = *k; i = low; j = hi; do { // 找出a[i]\u0026gt;=ak 时的i值 while (*i \u0026lt; ak) i++; // 找出a[j]\u0026gt;=ak 时的j值 while (*j \u0026gt; ak) j--; // 交换 a[i]与a[j]的值，并移动i和j if (i\u0026lt;=j) { buf = *i; (*i)++ = *j; (*j)-- = buf; } } while (i\u0026lt;=j); // 更新low 和 hi if (j\u0026lt;k) low = i; if (k\u0026lt;i) hi = j; } return (*k); }   参考资料 Quick Select Algorithm快速选择算法\n选取第K大数的快速选择算法和注意事项\n维基百科\nMadagascar\n","permalink":"https://blog.nickwhyy.top/post/2018-04-30-hoare-algorithm/","tags":["快速选择"],"title":"Hoare's algorithm"},{"categories":["地震学"],"contents":"前言 主要记录下常用各种子波函数以及对应的图形。\nRicker子波 $ S(t)=(1-2\\pi^2f^2t^2)exp(-\\pi^2f^2t^2) $\n1 2 3  function [w] = ricker(fpeak,t,tdelay) w = exp(-pi^2*fpeak^2*(t-tdelay).^2).*(1-2*pi^2*fpeak^2*(t-tdelay).^2); return   Ricker子波的一阶导数： $$S(t)=2\\pi^2f^2t(2\\pi^2f^2t^2-3)exp(-\\pi^2f^2t^2)$$\n1 2 3 4  function [w] = ricker1(fpeak,t,tdelay) w = 2*pi^2*fpeak^2*(t-tdelay).*(2*pi^2*fpeak^2*(t-tdelay).^2-3).*... exp(-pi^2*fpeak^2*(t-tdelay).^2); return   最小相位子波 $$S(t)=texp(-3.5ft)sin(2\\pi ft)$$\n1 2 3  function [w] = min_phase(fpeak,t,tdelay) w = (t-tdelay).*exp(-3.5*fpeak*(t-tdelay)).*sin(2*pi*fpeak*(t-tdelay)); return   Gauss子波的导数： $$S(t)=-A\\pi^2f^2texp(-\\pi^2f^2t^2)(3-2\\pi^2f^2t^2)$$\n1 2 3 4  function [w] = gauss1(fpeak,t,tdelay) w =-pi^2*fpeak^2*(t-tdelay).*exp(-pi^2*fpeak^2*(t-tdelay).^2).*... (3-2*pi^2*fpeak^2*(t-tdelay).^2); return   参考资料 罗焕宏.基于单程波算子的地震波场模拟及叠前深度偏移[D].中国石油大学,2010\n","permalink":"https://blog.nickwhyy.top/post/2018-04-27-seismic-wavelet/","tags":["地震子波"],"title":"地震子波"},{"categories":["地震学"],"contents":"前言 地震事件的合成主要用于测试一些信号处理的方法，比如插值、去噪等。为了避免大家重复造轮子，这里介绍一下合成地震事件的方法。\n线性地震事件合成步骤 前期准备 这里采用SAIG组开发的SeismicLab中公开的代码linear_events.m来进行线性地震数据的合成。 由于该代码中默认是要添加随机噪音的，有时候我们并不需要添加随机噪音的数据，因此，我对源程序进行了修改，将添加噪音的部分删除了，点击这里查看具体的代码内容。\n开始试验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  clear; close all; dt = 0.004; % 时间间隔 dx = 20; % 道间距 nt = 512; % 总时间采样个数 tmax = (nt-1)*dt; % 记录最大时刻 f0 = 25; % 地震子波的主频 nx = 128; % 空间采样个数 h = [0:dx:dx*(nx-1)]; % 偏移距 tau = [0.4, 0.7, 1.8]; % 共三个地震事件，其值为事件与时间轴的交点的时刻 p = [1.6/max(h), 0.5/max(h), -1.3/max(h)]; % 三个地震事件的射线参数 amp = [1, 1, 1]; % 三个地震事件的振幅 % 合成三个地震事件，d [d,h,t] = linear_events(dt,f0,tmax,h,tau,p,amp); %% figure; wigb(d,1,h,t); % 用SeismicLab中的`wigb.m`函数绘制波形图 set(gca,\u0026#39;TickDir\u0026#39;,\u0026#39;out\u0026#39;) ax = gca; ax.XAxisLocation = \u0026#39;top\u0026#39;; xlabel(\u0026#39;Distance (m)\u0026#39;); ylabel(\u0026#39;Time (s)\u0026#39;);   运行完上述代码后，得到的图形如下 双曲地震事件 前期准备 这里采用SAIG组开发的SeismicLab中公开的代码hyperbolic_events.m来进行线性地震数据的合成。 由于该代码中默认是要添加随机噪音的，有时候我们并不需要添加随机噪音的数据，因此，我对源程序进行了修改，将添加噪音的部分删除了，点击这里查看具体的代码内容。\n开始试验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  clear; close all; %% dt = 0.002; % 时间间隔 dx = 5; % 道间距 nt = 350; % 总时间采样个数 tmax = (nt-1)*dt; % 记录最大时刻 f0 = 30; % 地震子波的主频 nx = 80; % 空间采样个数 h = [0:dx:dx*(nx-1)]; % 偏移距 tau = [0.15, 0.28, 0.39]; % 共三个地震事件，其值为事件与时间轴的交点的时刻 v = [1500, 1750, 1800]; % 三个地震事件的速度 amp = [1, 1, 1]; % 三个地震事件的振幅 % 合成三个地震事件，d [d,h,t] = hyperbolic_events(dt,f0,tmax,h,tau,v,amp); figure; wigb(d,1,1:length(h),t); set(gca,\u0026#39;TickDir\u0026#39;,\u0026#39;out\u0026#39;) ax = gca; ax.XAxisLocation = \u0026#39;top\u0026#39;; xlabel(\u0026#39;Trace\u0026#39;); ylabel(\u0026#39;Time (s)\u0026#39;);   运行完上述代码后，得到的图形如下 ","permalink":"https://blog.nickwhyy.top/post/2018-04-23-linear-events/","tags":["合成数据"],"title":"合成地震事件"},{"categories":["macOS"],"contents":"Mac本身是支持NTFS写入的，只是NTFS是微软开发，由于版权和技术细节原因，苹果不愿公开说自己支持NTFS写入，也是有自己以后可能不支持NTFS写入的考量。\n方法一： 1.在terminal下使用命令diskutil list查询要挂载的NTFS硬盘名称\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  $ diskutil list UUID=7E84540E-D729-44B9-9AB8-2056C250DC5D none auto ro /dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *251.0 GB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_APFS Container disk1 250.8 GB disk0s2 /dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +250.8 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 76.4 GB disk1s1 2: APFS Volume Preboot 19.5 MB disk1s2 3: APFS Volume Recovery 509.8 MB disk1s3 4: APFS Volume VM 3.2 GB disk1s4 /dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *4.0 TB disk2 1: EFI EFI 209.7 MB disk2s1 2: Apple_HFS macOSbackup 1000.0 GB disk2s2 3: Microsoft Basic Data data 3.0 TB disk2s3   从输出的结果可以看到，最下面那个data即为我的名称。\n2.在terminal下使用命令diskutil info /Volumes/data查询该硬盘的UUID值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  $ diskutil info /Volumes/data Device Identifier: disk2s3 Device Node: /dev/disk2s3 Whole: No Part of Whole: disk2 Volume Name: data Mounted: Yes Mount Point: /Volumes/data Partition Type: Microsoft Basic Data File System Personality: NTFS Type (Bundle): ntfs Name (User Visible): Windows NT File System (NTFS) OS Can Be Installed: No Media Type: Generic Protocol: USB SMART Status: Not Supported Volume UUID: C0F838DA-F857-9CC0-2CC1-9CE6F19CE668 Disk / Partition UUID: 2E13FC4C-6FC4-469F-B8DE-FBBAA5F5907D Disk Size: 3.0 TB (3000273383424 Bytes) (exactly 5859908952 512-Byte-Units) Device Block Size: 512 Bytes Volume Total Space: 3.0 TB (3000273379328 Bytes) (exactly 5859908944 512-Byte-Units) Volume Used Space: 16.1 GB (16052121600 Bytes) (exactly 31351800 512-Byte-Units) (0.5%) Volume Available Space: 3.0 TB (2984221257728 Bytes) (exactly 5828557144 512-Byte-Units) (99.5%) Allocation Block Size: 4096 Bytes Read-Only Media: No Read-Only Volume: Yes Device Location: External Removable Media: Fixed   输出结果中Volume UUID即为data的UUID值。\n3.在/etc/fstab中添加如下一行\n1  UUID=C0F838DA-F857-9CC0-2CC1-9CE6F19CE668 none ntfs rw,auto,nobrowse   具体操作如下：\n1  $ sudo vim /etc/fstab   然后输入刚才那一行（UUID值根据自己电脑的情况更改），最后保存退出（wq）.\n4.退出自己的移动硬盘，然后拔出移动硬盘，再重新插上移动硬盘。这时，在桌面上不再显示移动硬盘的图标，但我们打开terminal，进入/Volumes文件夹就能看到了。\n1 2 3  $ cd /Volumes $ ls Macintosh HD\tdata\tmacOSbackup   5.通过软链接建立桌面快捷方式\n1 2  $ mkdir -p ~/Desktop/data $ ln -s /Volumes/data ~/Desktop/data   在桌面上，我们就能看到其快捷方式了。\n方法二. https://blog.plcent.com/archives/209 目前暂未测试该方法，所以没有把详细过程记录下来。\n补充说明 方法一对于最新的系统macOS High Sierra是有效的。\n参考资料 https://techsviewer.com/write-ntfs-driver-macos-high-sierra/\nhttps://blog.plcent.com/archives/209\naijiv提供的答案\n修订历史  2018-04-06： 初稿； 2018-08-05： 重排格式；  ","permalink":"https://blog.nickwhyy.top/post/2018-04-06-macos-ntfs/","tags":["macOS","NTFS"],"title":"macOS 挂载 NTFS 格式硬盘"},{"categories":["绘图"],"contents":"波形图 比如，绘制子波形态，单道地震记录等。采用sfgraph来绘图，类似与Matlab的plot命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  # plot wavelet from rsf.proj import * par={ } def waveplot(custom,par): return \u0026#39;\u0026#39;\u0026#39; graph title=\u0026#34;\u0026#34; min1=%gmin2=0 max2=+1 plotfat=5 plotcol=5 label1=%sunit1=%slabel2=\u0026#34;Amplitude\u0026#34; unit2=\u0026#34;\u0026#34; parallel2=n screenratio=0.5 screenht=7 %s\u0026#39;\u0026#39;\u0026#39; % (par[\u0026#39;oxx\u0026#39;],par[\u0026#39;lxx\u0026#39;],par[\u0026#39;uxx\u0026#39;], par[\u0026#39;labelattr\u0026#39;]+\u0026#39; \u0026#39;+custom) par[\u0026#39;labelattr\u0026#39;]=\u0026#39; parallel2=n labelsz=6 labelfat=3 titlesz=12 titlefat=3 \u0026#39; par[\u0026#39;lxx\u0026#39;]=\u0026#39;x\u0026#39; par[\u0026#39;uxx\u0026#39;]=\u0026#39;m\u0026#39; par[\u0026#39;oxx\u0026#39;]= 0. Result(\u0026#39;wav\u0026#39;,\u0026#39;transp |\u0026#39; + waveplot(\u0026#39;\u0026#39;,par))   说明wav为绘图的数据，其维度必须为1xn2的形式。\n示例：暂缺\n3D图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  par = { \u0026#39;nx\u0026#39;:41, \u0026#39;ox\u0026#39;:0, \u0026#39;dx\u0026#39;:0.05, \u0026#39;lx\u0026#39;:\u0026#39;x\u0026#39;, \u0026#39;ux\u0026#39;:\u0026#39;km\u0026#39;, \u0026#39;ny\u0026#39;:41, \u0026#39;oy\u0026#39;:0, \u0026#39;dy\u0026#39;:0.05, \u0026#39;ly\u0026#39;:\u0026#39;y\u0026#39;, \u0026#39;uy\u0026#39;:\u0026#39;km\u0026#39;, \u0026#39;nz\u0026#39;:41, \u0026#39;oz\u0026#39;:0, \u0026#39;dz\u0026#39;:0.05, \u0026#39;lz\u0026#39;:\u0026#39;z\u0026#39;, \u0026#39;uz\u0026#39;:\u0026#39;km\u0026#39; } # 生成三维数据 Flow(\u0026#39;data\u0026#39;,None,\u0026#39;\u0026#39;\u0026#39;math n1=41 n2=41 n3=41 o1=-1 o2=-1 o3=-1 d1=0.05 d2=0.05 d3=0.05 output=\u0026#34;exp(-2*(x1^2+x2^2+x3^2))\u0026#34;\u0026#39;\u0026#39;\u0026#39;) # 绘图 fdmod.param(par) # 立体图 Result(\u0026#39;data\u0026#39;, \u0026#39;byte gainpanel=a pclip=95 |\u0026#39; +fdmod.cgrey3d(\u0026#39;flat=y \u0026#39;,par)) # 三视图 Result(\u0026#39;data1\u0026#39;,\u0026#39;data\u0026#39;,\u0026#39;byte gainpanel=a pclip=95 |\u0026#39; +fdmod.cgrey3d(\u0026#39;flat=n \u0026#39;,par))   立体图\n三视图\n绘制box 常用于论文中的局部比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  from rsf.proj import * from rsf.recipes import fdmod,rwezo from math import pi zmin=0 zmax=1 xmin=0 xmax=1 # make box data fdmod.makebox(\u0026#39;box\u0026#39;,zmin,zmax,xmin,xmax,par) # __________________ zmin # | | # | | # | | # | | # xmin |__________________| xmax zmax # draw box Plot(\u0026#39;box\u0026#39;,fdmod.bbplot(\u0026#39;\u0026#39;,par))   半圆 常用于脉冲响应的绘制。\n给定参数 ``` {.py} xcenter = 1285.0　# 圆心x坐标 zcenter = 0.0　# 圆心z坐标　sampling = 1000　# 采样点数 radius = 768　# 半径 ```  绘图 ``` {.py} fdmod.circle('cc',xcenter,zcenter,radius,sampling,par) Plot( 'cc',fdmod.ssplot('plotfat=7 plotcol=2 ',par)) ```  结果 椭圆 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #定义临时处理Flow def Temp(o,i,r): Flow(o,i,r+ \u0026#39; datapath=%s \u0026#39;%os.environ.get(\u0026#39;TMPDATAPATH\u0026#39;,os.environ.get(\u0026#39;DATAPATH\u0026#39;))) #椭圆模块 def ellipse(cc,xcenter,zcenter,semiA,semiB,sampling,par): Temp(cc+\u0026#39;_x\u0026#39;,None, \u0026#39;math n1=%d d1=%g o1=%g output=\u0026#34;%g+%g*cos(%g*x1/180)\u0026#34;\u0026#39; % (sampling,360./sampling,0.,xcenter,semiA,pi) ) Temp(cc+\u0026#39;_z\u0026#39;,None, \u0026#39;math n1=%d d1=%g o1=%g output=\u0026#34;%g+%g*sin(%g*x1/180)\u0026#34;\u0026#39; % (sampling,360./sampling,0.,zcenter,semiB,pi) ) Flow(cc,[cc+\u0026#39;_x\u0026#39;,cc+\u0026#39;_z\u0026#39;], \u0026#39;\u0026#39;\u0026#39; cat axis=2 space=n ${SOURCES[0]} ${SOURCES[1]} | transp | put label1=\u0026#34;\u0026#34; unit1=\u0026#34;\u0026#34; label2=\u0026#34;\u0026#34; unit2=\u0026#34;\u0026#34; \u0026#39;\u0026#39;\u0026#39;, stdin=0) xcenter=(par[\u0026#39;ox\u0026#39;]+(par[\u0026#39;nx\u0026#39;]-1)*par[\u0026#39;dx\u0026#39;])/2.0　# 坐标系中心x zcenter=par[\u0026#39;oz\u0026#39;] ＃坐标系中心z ab=par[\u0026#39;dx\u0026#39;]*(361-150)# 计算焦距 semiA=(par[\u0026#39;kt\u0026#39;]-50)*par[\u0026#39;dt\u0026#39;]*1500　# 计算a semiB=np.sqrt(semiA**2.0-(ab/2.0)**2.0) # 计算b ellipse(\u0026#39;ec\u0026#39;,xcenter,zcenter,semiA,semiB,500,par) # 生成椭圆坐标 Plot( \u0026#39;ec\u0026#39;,fdmod.ssplot(\u0026#39;plotfat=10 plotcol=2 symbol=.\u0026#39;,par))　# 绘制椭圆   结果\n椭圆坐标系 1 2 3 4 5 6 7 8 9 10  # 生成坐标系文件 rays.rsf Flow(\u0026#39;rays\u0026#39;,\u0026#39;datRC velo\u0026#39;, \u0026#39;\u0026#39;\u0026#39; %(rays)slrays vel=${SOURCES[1]} dt=%(dt)g nt=%(nt)d ot=%(ot)g minang=%(minang)g maxang=%(maxang)g \u0026#39;\u0026#39;\u0026#39;%par) # 绘制椭圆坐标系 rwezo.cos(\u0026#39;rays\u0026#39;,20,100,\u0026#39;\u0026#39;,par)   ","permalink":"https://blog.nickwhyy.top/post/2018-03-31-rsf-plot/","tags":["Madagascar","绘图"],"title":"Madagascar绘图总结"},{"categories":["编程"],"contents":"由于之前装机时 /boot 只分配了 200MB 的空间，而 Ubuntu 16.04 LTS 会自动更新内核， 导致某次开机突然提示 /boot 空间不足， 然后发现 /boot下有两个系统内核文件，一个 44M 左右， 再加上一些其他的文件，加起来足足占了 70% 的使用空间，后期如果再更新系统，将会十分不便。因此想到了扩大 /boot 空间。\n网上的一些博文都是简单的介绍了如何增大/boot, 没有提供一个详细的步骤，这里总结了各大博文的精华之处，整理出来供大家参考。\n 运行sudo cat /etc/fstab  1 2 3 4 5 6 7 8 9 10 11 12 13 14  ➜ ~ sudo cat /etc/fstab # /etc/fstab: static file system information. # # Use \u0026#39;blkid\u0026#39; to print the universally unique identifier for a # device; this may be used with UUID= as a more robust way to name devices # that works even if disks are added and removed. See fstab(5). # # \u0026lt;file system\u0026gt; \u0026lt;mount point\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; # / was on /dev/sda7 during installation UUID=50b02ca0-b7d6-47e7-b822-9d30caac57ec / ext4 errors=remount-ro 0 1 # /boot was on /dev/sda6 during installation UUID=c1a85b1e-b617-4f2f-82d4-0ed61e8347ba /boot ext4 defaults 0 2 # swap was on /dev/sda5 during installation UUID=3db90030-2801-4ba3-b126-7bb0af433172 none swap sw 0 0    运行sudo ls -al /dev/disk/by-uuid/*  1 2 3 4 5 6 7 8 9 10 11  ➜ ~ sudo ls -al /dev/disk/by-uuid/* lrwxrwxrwx 1 root root 10 8月 13 10:28 /dev/disk/by-uuid/041838F41838E678 -\u0026gt; ../../sda4 lrwxrwxrwx 1 root root 10 8月 13 10:28 /dev/disk/by-uuid/3db90030-2801-4ba3-b126-7bb0af433172 -\u0026gt; ../../sda5 lrwxrwxrwx 1 root root 10 8月 13 10:27 /dev/disk/by-uuid/40D69E0DD69E0378 -\u0026gt; ../../sdb1 lrwxrwxrwx 1 root root 10 8月 13 10:27 /dev/disk/by-uuid/50b02ca0-b7d6-47e7-b822-9d30caac57ec -\u0026gt; ../../sda7 lrwxrwxrwx 1 root root 10 8月 13 10:27 /dev/disk/by-uuid/6C7AC53E7AC505B4 -\u0026gt; ../../sdc1 lrwxrwxrwx 1 root root 10 8月 13 10:28 /dev/disk/by-uuid/7AC85EFBC85EB4DB -\u0026gt; ../../sda2 lrwxrwxrwx 1 root root 10 8月 13 10:27 /dev/disk/by-uuid/8646ADF646ADE6E1 -\u0026gt; ../../sdb2 lrwxrwxrwx 1 root root 10 8月 13 10:28 /dev/disk/by-uuid/948E13708E134A5E -\u0026gt; ../../sda1 lrwxrwxrwx 1 root root 10 8月 13 10:27 /dev/disk/by-uuid/a6686297-cdf6-4600-9465-dcf2de344662 -\u0026gt; ../../sda8 lrwxrwxrwx 1 root root 10 8月 13 10:28 /dev/disk/by-uuid/c1a85b1e-b617-4f2f-82d4-0ed61e8347ba -\u0026gt; ../../sda6   通过这个命令将自己的 /boot 与 硬盘编号sd* 以及 uuid 值对应起来。\n 制作一个live 启动盘， 用它来启动系统。 然后在 live 系统中运行gparted。  1  $ sudo gparted   这时会出现一个图形界面。修改分区信息在图形界面很简单，我只说明一下我的分区策略：\n由于我的 swap 分区与 /boot 挨着， 而且 swap 分区空间也挺大，大概分了15GB。 这里采用的方式为直接将 swap 进行 resize, 然后将后面大概1gb的空间留出来。 接着对/boot 进行 resize 然后再刚才留出来的1gb 加进来即可。最后, 点击上面的绿色的√即可完成重新分区的过程。\n  确认 /boot等的 uuid 值是否改变 在 live 系统中看 /boot 的 uuid 值可通过 gparted 右键查看，然后与你之前在原来系统上运行的结果比较，看是否一致。 使用gparted 右键查看的时候，不要选择 New uuid ，不然你得修改/etc/fstab 文件，将其对应上。 如果在原来系统上运行的结果没有保存，可在 live 里访问原来系统的文件， 然后再查看/etc/fstab 文件。\n  重启系统。\n  参考资料：  http://forum.ubuntu.org.cn/viewtopic.php?t=481011 http://blog.csdn.net/caz28/article/details/50827904  ","permalink":"https://blog.nickwhyy.top/post/2018-02-04-boot-partition/","tags":["Linux"],"title":"Linux /boot 重新分区"},{"categories":["绘图"],"contents":"前言 SPECFEM2D 本身程序运行的结果也可以输出波场快照，但是其图形由于是自己生成的，并不美观，也不便于 与其他模拟程序生成的波场快照进行对比。因此本文记录如何采用 GMT 绘制 SPECFEM2D 所生成的波场快照。\n运行程序中的一些参数设置 这里主要显示绘图需要的部分参数：\n1 2 3 4 5  #### for wavefield dumps #### output_wavefield_dumps = .true. #将这里设为 true， 主要是输出绘图文件 imagetype_wavefield_dumps = 1 # display 1=displ vector 2=veloc vector 3=accel vector 4=pressure， 这儿一般选择绘制位移，也可以选择绘制其他的，根据自己的需要进行修改 use_binary_for_wavefield_dumps = .false. # use ASCII or single-precision binary format for the wave field dumps， 由于 GMT 画 ASCII 文件相对简单一点，因此这里选择 false   运行程序并绘图 运行完程序之后，在OUTPUT_FILES文件夹下应该存在很多波场快照的文件(文件名类似于 wavefield0000100_01.txt)，最后还有一个网格节点坐标的文件(文件名类似于wavefield_grid_for_dumps.txt)。其中波场快照文件共有两列，分别为水平向和垂直向的波场信息。网格节点坐标文件也有两列数据，每一行记录一个网格节点的坐标信息(x z)。波场快照文件和网格节点坐标文件行数都相等，为总共计算的网格点数（程序运行的时候会在终端上打印该节点数）。\n构建绘图原始文本 由于波场快照文件记录的是每个网格节点上的波场值，因此和传统的有限差分程序输出的波场快照文件不同。属于不规则网格数据（即使是一个均匀分布的网格），因此无法通过 SU, Madagascar 直接绘制波场快照信息。只能通过绘制一个 xyz 数据体的格式来进行，这个采用 GMT 很容易实现。但前提是需要把原来输出的波场快照，网格节点转化为一个文本文件，然后再使用 GMT 来绘图。\n构建绘图原始文本可采用 Linux 下的 paste 命令，其操作如下\n1 2  # 将 wavefield0001000_01.txt 按列粘贴到 wavefield_grid_for_dumps.txt 中，并存储为 wavefield_ux_uz.txt $ paste wavefield_grid_for_dumps.txt wavefield0001000_01.txt \u0026gt; wavefield_ux_uz.txt   通过上述处理后， wavefield_ux_uz.txt文件的前两列分别为 x,y 坐标；后两列为 ux, uz 值。\nGMT绘图脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #!/bin/bash  # 模型的尺寸为1000 m * 1000 m R=\u0026#34;-R0/1000/0/1000\u0026#34; data=\u0026#34;wavefield_ux_uz.txt\u0026#34; grid=\u0026#34;output.grd\u0026#34; J=\u0026#34;-JX10c/10c\u0026#34; PS=\u0026#34;wavefield_ux.ps\u0026#34; # 将前三列数据生成网格文件，用于绘制ux；若要绘制uz,修改为-i0,1,3即可 gmt surface -i0,1,2 $R $data -I2/2 -G$grid # 绘制底图 gmt psbasemap $R $J -P -Bxa100 -Bya100 -K \u0026gt; $PS # 绘制波场快照 gmt grdimage $grid $R $J -I -Cgray -O \u0026gt;\u0026gt; $PS # #### gmt psconvert $PS -Tg -E300 -A -Tf rm gmt.history rm *.grd   结果图 只是一个简单的示例，未添加横坐标和纵坐标的label，大家可自行修改。这里显示的绘制的结果不是ux,也不是uz, 而是u=sqrt(ux**2 + uz**2)。\n 注意： 之前波场输出文件的选项`use_binary_for_wavefield_dumps = .false.`建议选为false，生成文本文件。最开始我选的是true主要的考虑是占用更小的磁盘空间，当时想着用 ximage 来画一个初步的波场快照信息，结果通过分析文件字节数怎么算都有个二倍的数据量，后面才想到是通过记录了两个波场分量的信息。如果采用ascii文本文件输出的话，就不会走这么多弯路了。 ","permalink":"https://blog.nickwhyy.top/post/2017-10-28-specfem2d-gmt/","tags":["GMT","SPECFEM2D"],"title":"采用 GMT 绘制 SPECFEM2D 波场快照"},{"categories":["绘图"],"contents":"前言 盐丘轮廓的绘制在地震偏移领域用途十分广泛，主要目的是为了分析偏移结果的好坏。当偏移结果和盐丘的轮廓基本吻合时，偏移质量就很高。最开始绘制轮廓的时候我采用的PS法，通过磁性套索把整个盐丘模型轮廓勾勒出来，然后再保存下来，与偏移结果进行对比。这里介绍一种直接通过 Madagascar 脚本的形式来绘制盐丘的结果，非常方便，可复用性很强，还可以用于其他的方面。此方法也借鉴于Prof. Sava 在 Madagascar book 文件夹下贡献的一个关于 Sigsbee 模型的脚本。\n操作 下面通过脚本的形式来说明主要的操作步骤：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  # 提取盐丘外形 Flow( \u0026#39;salt\u0026#39;,\u0026#39;vraw\u0026#39;,\u0026#39;add add=-4.280 | clip clip=0.300 \u0026#39;) # vraw为盐丘速度模型,其速度值单位为km/s #　计算水平梯度和垂直梯度 Flow( \u0026#39;edgez\u0026#39;,\u0026#39;salt\u0026#39;,\u0026#39; igrad square=y\u0026#39;) Flow( \u0026#39;edgex\u0026#39;,\u0026#39;salt\u0026#39;,\u0026#39;transp | igrad square=y | transp\u0026#39;) Flow( \u0026#39;edge\u0026#39;,\u0026#39;edgez edgex\u0026#39;, \u0026#39;math z=${SOURCES[0]} x=${SOURCES[1]} output=\u0026#34;z+x\u0026#34;\u0026#39;) # 对于给定的阈值进行mask，大于阈值部分为1，小于则为0 Flow( \u0026#39;mask\u0026#39;,\u0026#39;edge\u0026#39;,\u0026#39;mask min=0.04\u0026#39;) # 计算盐丘外壳的x与z坐标 for x in (\u0026#39;x1\u0026#39;,\u0026#39;x2\u0026#39;): if(x==\u0026#39;x1\u0026#39;): o=\u0026#39;zs\u0026#39; if(x==\u0026#39;x2\u0026#39;): o=\u0026#39;xs\u0026#39; Flow(o,\u0026#39;edge mask\u0026#39;, \u0026#39;\u0026#39;\u0026#39; math output=%s | put n1=1 n2=%d | headerwindow mask=${SOURCES[1]} | window \u0026#39;\u0026#39;\u0026#39; % (x,par[\u0026#39;nz\u0026#39;]*par[\u0026#39;nx\u0026#39;])) # 合并x和z坐标 Flow(\u0026#39;ss\u0026#39;,[\u0026#39;xs\u0026#39;,\u0026#39;zs\u0026#39;], \u0026#39;\u0026#39;\u0026#39; cat axis=2 space=n ${SOURCES[0]} ${SOURCES[1]} | transp | window j2=2 \u0026#39;\u0026#39;\u0026#39;, stdin=0) fdmod.param(par) # 绘制外壳图像 Plot( \u0026#39;ss\u0026#39;,fdmod.ssplot(\u0026#39;plotfat=2 plotcol=6 symbol=.\u0026#39;,par))    ","permalink":"https://blog.nickwhyy.top/post/2017-10-18-plot-salt/","tags":["Madagascar","SEG","EAGE"],"title":"Madagascar 绘制 SEG/EAGE 模型的盐丘轮廓"},{"categories":["安装"],"contents":"下载 要下载SPECFEM3D，可以在终端中输入以下命令：\n1  $ git clone --recursive --branch devel https://github.com/geodynamics/specfem3d.git     注意：如果直接从 github 手动下载，然后再安装，有可能会出现一些问题，原因可能在于从 github 上直接下载的版本一般情况下并非 release 版本，因而针对不同的机器，可能会出现一些问题。若无法解决，建议采用上述语句重新下载 SPECFEM3D，然后再安装。\n可选依赖包 以下安装包均为可选。\n ifort编译器，可使用 gfortran 代替。 mpi并行环境，可安装不带 MPI 加速的版本 scotch，安装SPECFEM3D时会自动安装其目录下绑定的scotch版本，但版本不是最新版本  上述工具中建议安装 ifort 编译器，使用 gfortran 编译，可能会出现一些问题且编译效率低。\n安装 进入specfem3d的根目录进行安装。\n安装不带MPI的版本 1 2  $ ./configure FC=ifort --without-mpi $ make   安装带MPI的版本 1 2  $ ./configure FC=ifort MPIFC=/opt/mpich3.3/bin/mpif90 MPI_INC=/opt/mpich3.3/include --with-mpi $ make     注意：这里最好显式地给出mpif90的路径，不然编译的时候会调用系统里 安装的其他mpif90,然后就是给出MPI的include变量MPI_INC，编译 的时候会用到mpi.h头文件，所以需要从MPI_INC里找。\n安装带 MPI 且使用非 SPECFEM3D 绑定的 scotch 版本 和安装带 MPI 的版本的差不多，只不过，采用的是下面的configure\n1 2  $ ./configure FC=ifort MPIFC=/opt/mpich3.3/bin/mpif90 MPI_INC=/opt/mpich3.3/include --with-mpi -with-scotch-dir=/opt/scotch_6.0.4 $ make     注意：本文给出的/opt/mpich3.3,/opt/scotch_6.0.4只是个例子， 大家根据自己 mpich 和 scotch 的安装位置进行适当修改，没有必要一定 要将 mpich 和 scotch 安装在/opt下。\n编译完成后，可以在 specfem3d 的根目录下发现有一个新的目录 bin/,该目录下包含 specfem3d 的二进制可执行文件。\n修订历史  2017-10-10：初稿； 2018-08-01：更新无效的链接； 2018-08-05：新增关于下载的注意事项； 2018-11-25：更新mpich为3.3。  ","permalink":"https://blog.nickwhyy.top/post/specfem3d/","tags":["SPECFEM3D"],"title":"Linux 下安装 SPECFEM3D"},{"categories":["地震学软件"],"contents":"前言 在勘探地球物理中，往往一个程序会重复计算多次，比如叠前数据的合成（需要对一个有限差分程序往复执行上 百次，最后得到一个叠前的炮集记录）。因此学会对程序进行优化是一个很好的解决方案。\nGNU C Compiler (GCC) 自带了一个通用的 Profile 工具 gprof， 用于对程序各函数的运行时间进行 统计，方便用户确认程序的 Hot Spot(运行耗时最多的函数)。下面将介绍如何将该工具用于 Madagascar 程序的 Profile 中。\n准备工作 首先，准备好要 Profile 的程序，这里为Mfdtd2d.c。然后写一个用来编译该程序的 SConstruct 脚本，代码如下：\n``` import os, sys, re, string try: import bldutil glob_build = True # scons command launched in RSFSRC srcroot = '../..' # cwd is RSFSRC/build/user/jeff Import('env bindir libdir pkgdir') env = env.Clone() except: glob_build = False # scons command launched in the local directory srcroot = os.environ.get('RSFSRC', '../..') sys.path.append(os.path.join(srcroot,'framework')) import bldutil env = bldutil.Debug() # Debugging flags for compilers ################## very import !!!!!!!! ######################### env['CC'] = 'gcc -pg' # add option `-pg` to gcc to enable gprof ################################################################# bindir = libdir = pkgdir = None targets = bldutil.UserSconsTargets() # C mains targets.c = ''' fdtd2d ''' targets.build_all(env, glob_build, srcroot, bindir, libdir, pkgdir) ```  从编译脚本可以看到 gcc 的编译选项里增加了-pg选项，这是采用gprof来 Profile 所必须的。 如果自己手写编译脚本的话，记得在编译和链接两步都要加上-pg选项，否则无法成功运行gprof。\n编译并链接代码 $ scons  运行完该语句会在当前目录下生成一个可执行的二进制文件sffdtd2d。然后我们正常运行该程序。假设 其所需的参数为：速度模型vel.rsf, 子波wav.rsf，生成的地震记录为dd.rsf。然后运行该程序\n$ ./sffdtd2d \u0026lt; vel.rsf wav=wav.rsf \u0026gt; dd.rsf  Profile 执行完./sffdtd2d \u0026lt; vel.rsf wav=wav.rsf \u0026gt; dd.rsf语句后，我们可以在当前目录下发现一个命名 为gmon.out的文件。下一步将使用该文件进行 Profile。\n执行gprof ./sffdtd2d gmon.out -p，将得到下列信息：\n$ gprof ./sffdtd2d gmon.out -p Flat profile: Each sample counts as 0.01 seconds. % cumulative self self total time seconds seconds calls ms/call ms/call name 96.28 76.63 76.63 1000 76.63 76.63 fd_kernel 1.99 78.21 1.58 main 1.75 79.60 1.39 5000 0.28 0.28 fun() 0.00 79.60 0.00 4 0.00 0.00 fun2() 0.00 79.60 0.00 2 0.00 0.00 fun3() 0.00 79.60 0.00 1 0.00 0.00 fun4() 0.00 79.60 0.00 1 0.00 0.00 fun5()  通过该信息，我们发现fd_kernel这个函数占用了96.28%的计算时间，因此我们找到了程序的 Hot Spot ，从而可以通过采用 OpenMP， MPI, CUDA C等方式进一步对程序进行优化加速。\n参考资料：  Gprof官方文档 SCons官方文档 使用 GNU profile 来提高代码运行速度  ","permalink":"https://blog.nickwhyy.top/post/optmize-rsf-code/","tags":["Madagascar"],"title":"优化 Madagascar 程序"},{"categories":["安装"],"contents":"本文介绍如何在 Ubuntu 16.04 LTS 上安装 OpenCV 2.4.13.3 。\n下载 OpenCV Release 版本的官网为： http://opencv.org/releases.html。选择最新的 OpenCV 2.4.13.3 进行下载。\n依赖库与编译工具 # 更新软件源 $ sudo apt update # 安装编译工具 $ sudo apt install -y build-essential # 安装依赖包 $ sudo apt install -y cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev # 安装可选包 $ sudo apt install -y python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev  注： 这里使用apt是 Ubuntu 16.04 LTS 的一个特性，其他发行版本请补全为apt-get。\n编译安装 $ unzip opencv-2.4.13.3.zip # 解压 $ cd opencv-2.4.13.3 $ mkdir build # 新建一个文件夹用于存放临时文件 $ cd build $ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local \\ -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=ON .. $ make -j $ sudo make install  环境变量配置 将 OpenCV 的库加入到路径，从而让系统可以找到\n$ sudo vim /etc/ld.so.conf.d/opencv.conf  在/etc/ld.so.conf.d/opencv.conf中输入如下内容：\n/usr/local/lib  然后运行\n$ sudo ldconfig #使配置生效  接着编辑/etc/profile\n$ sudo vim /etc/profile  在文件末尾添加\nPKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig export PKG_CONFIG_PATH  保存该文件。\n$ source /etc/profile # 使其生效 $ sudo updatedb # 更新数据库  测试是否安装成功 $ python Python 2.7.12 (default, Nov 19 2016, 06:48:10) [GCC 5.4.0 20160609] on linux2 Type \u0026quot;help\u0026quot;, \u0026quot;copyright\u0026quot;, \u0026quot;credits\u0026quot; or \u0026quot;license\u0026quot; for more information. \u0026gt;\u0026gt;\u0026gt; import cv2 \u0026gt;\u0026gt;\u0026gt; cv2.__version__ '2.4.13.3' \u0026gt;\u0026gt;\u0026gt; ","permalink":"https://blog.nickwhyy.top/post/opencv/","tags":["OpenCV"],"title":"Linux 下安装 OpenCV"},{"categories":["安装"],"contents":"Chrome $ wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb # 下载 32bit $ wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb # 下载 64bit $ sudo dpkg -i google-chrome-stable_current_amd64.deb  安装过程中如遇到错误提示,直接执行以下命令来安装 Chrome 浏览器需要的类库\n$ sudo apt-get -f install  Mendeley Mendeley 是一个跨平台的文献管理软件,其内部自带了一个可以添加注释的 PDF 阅读器。下载链接:https://www.mendeley.com/download-mendeley-desktop 安装:\n $ sudo apt-get install libqtwebkit-dev # 安装依赖包 $ sudo dpkg -i mendeleydesktop_1.15.1-stable_amd64.deb $ cd /opt/mendeleydesktop/bin $ ./install-mendeley-link-handler.sh /opt/mendeleydesktop/bin/mendeleydesktop  搜狗输入法 Linux 下有两大输入法框架:ibus 和 fcitx,其中 fcitx 的体验要比 ibus 好,因此选择 fcitx 框架,并安装搜狗输入法。\n$ sudo apt-get install fcitx  与此同时,我们可以上搜狗官网下载搜狗输入法 linux 版:http://pinyin.sogou.com/linux/ 下载完搜狗输入法的安装包后,我们切换至下载此安装包的目录,进行安装\n$ sudo dpkg -i sogoupinyin_2.1.0.0068_amd64.deb  安装完后,需要 logout 再 login，然后在终端中输入\n$ fcitx-config-gtk3  在 Input Method 栏中,点击 +, 然后选择搜狗输入法(Sogou Pinyin)。设置好后,采 用快捷键 Ctrl+Space 即可调出搜狗输入法。\nJDK1.8  上Oracle官网下载JDK1.8 把JDK安装到/usr/lib/jvm这个路径下。如果系统没有该路径则创建该路径。 把下载好的压缩包文件解压到/usr/lib/jvm这个路径下  1  sudo tar zxvf jdk-8u111-linux-x64.tar.gz -C /usr/lib/jvm   配置环境变量，在用户根目录下的.bashrc文件中追加如下内容  1 2 3 4  export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_111 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH   重启终端让其生效或者在当前终端下输入 $source ~/.bashrc  参考 http://www.linuxidc.com/Linux/2013-11/93012.htm\n","permalink":"https://blog.nickwhyy.top/post/daily/","tags":["常用软件"],"title":"Linux 下常用软件安装"},{"categories":["安装"],"contents":"首先要知道的是 MPI 并不是一种编程语言，只是一种并行库，用来指示编译器自己的程序中哪些地方需要并行，哪些地方正常串行等等。目前常用的有 MPICH 和 OPENMPI 两个 MPI 库，这里选择 MPICH 来进行安装。\n其次， MPICH 最好从源码编译，这样一来可以得到和自己机器相匹配的最优性能，二来会避免今后可能出现的一些错误（我测试过直接安装 Debian 自带的 MPICH 包，结果安装过程没问题，编译程序，运行程序会出现一些错误，可能与机器相关吧）\n下载 MPICH最新版本目前为 3.3， 下载地址为：https://www.mpich.org/downloads/\n安装 进入到 MPICH 的下载目录，然后解压文件\n1  tar zxvf mpich-3.3.tar.gz   然后切换至 MPICH 的源文件目录，运行configure,并指定安装目录。\n1 2  cd mpich-3.3 ./configure --prefix=/opt/mpich3.3   configure完成之后，直接$ make可编译 MPICH 源文件目录下的所有文件，接着# make install就可以将 MPICH 安装在指定的安装目录。\n  注1：这里我没有指定 C 和 Fortran 的编译器，因为 MPICH3.2 默认采用 Intel 的编译器来进行编译源文件，如果没有 Intel 编译器也会自动configure系统自带的一些编译器来进行编译，如果想手动指定编译器的话可以设置FC,CC等环境变量，然后再进行编译。\n  注2：如果./configure --prefix=/opt/mpich3.3过程中报错configure: error: unable to determine matching C type for C++ bool，可修改为./configure FC=/opt/intel/composer_xe_2013.2.146/bin/intel64/ifort CC=gcc CXX=g++ --prefix=/opt/mpich3.3,一般情况下可以顺利configure。\n环境变量设置 将下列语句添加到$HOME/.bashrc:\n1 2 3  # MPICH 3.3 export PATH=$PATH:/opt/mpich3.2/bin export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/mpich3.3/lib   最后使用$ source $HOME/.bashrc使环境变量生效。\n","permalink":"https://blog.nickwhyy.top/post/mpich/","tags":["MPI"],"title":"Linux 下安装 MPICH"},{"categories":["安装"],"contents":" 做好数据备份(最重要) 升级Debian 8系统上的所有软件 在升级到Debian 9系统之前，要把当前系统上的所有软件升级到最新版本，输入下面的命令：  1 2  $ sudo apt-get update $ sudo apt-get upgrade -y   如果升级的过程中遇到个人软件下载存在问题，那就是源的问题，更换其他源即可解决。 3. 更新source.list软件源文件 现在编辑Debian的apt软件源文件/etc/apt/sources.list，将文件中所有的jessie替换成stretch。我们可以用sed命令来实现。\n1  $ sudo sed -i \u0026#39;s/jessie/stretch/g\u0026#39; /etc/apt/sources.list   再次升级软件包 在更新完软件源文件后，先升级软件包。这一步被称为最小化升级(minimal upgrade)。  1 2  $ sudo apt-get update $ sudo apt-get upgrade -y   升级系统版本至Debian 9 Stretch 再升级系统版本，输入下面的命令。这一步被称为全体升级(full upgrade)。  1  $ sudo apt-get dist-upgrade -y   清除旧的依赖关系和软件安装包 分别执行下面的两个命令  1 2  $ sudo apt-get autoremove $ sudo apt-get clean   验证系统版本 现在你的系统应该成功地升级到了Debian 9。重启系统，然后检查系统版本。  1  # reboot   查看当前系统的版本\n1 2 3 4 5 6  root@debian:~# lsb_release -a No LSB modules are available. Distributor ID: Debian Description: Debian GNU/Linux 9.0 (stretch) Release: 9.0 Codename: stretch   ","permalink":"https://blog.nickwhyy.top/post/debian/","tags":["Linux","Debian"],"title":"Debian升级系统至Stretch"},{"categories":["高性能计算"],"contents":"本文介绍如何在 Ubuntu 16.04 LTS 上安装 CUDA-8.0 。\n下载 下载之前首先确定自己的电脑的显卡为Nvidia的显卡。其次是查询自己电脑的操作系统。\n确定自己有NVIDIA的GPU。 1  $ lspci | grep -i nvidia   如果有显示nvidia的显卡信息，则表示具备上述条件。一个符合条件的示例如下：\n1 2 3  nick@seis:~$ lspci | grep -i nvidia 01:00.0 VGA compatible controller: NVIDIA Corporation Device 1b00 (rev a1) 01:00.1 Audio device: NVIDIA Corporation Device 10ef (rev a1)   确定自己的操作系统是cuda官网列出的支持的操作系统： 1  $ uname -m \u0026amp;\u0026amp; cat /etc/*release   官网上列出的有Fedora, OpenSUSE, RHEL, CentOS, SLES, Ubuntu。一个符合条件的示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  nick@seis:~$ uname -m \u0026amp;\u0026amp; cat /etc/*release x86_64 DISTRIB_ID=Ubuntu DISTRIB_RELEASE=16.04 DISTRIB_CODENAME=xenial DISTRIB_DESCRIPTION=\u0026#34;Ubuntu 16.04.1 LTS\u0026#34; NAME=\u0026#34;Ubuntu\u0026#34; VERSION=\u0026#34;16.04.1 LTS (Xenial Xerus)\u0026#34; ID=ubuntu ID_LIKE=debian PRETTY_NAME=\u0026#34;Ubuntu 16.04.1 LTS\u0026#34; VERSION_ID=\u0026#34;16.04\u0026#34; HOME_URL=\u0026#34;http://www.ubuntu.com/\u0026#34; SUPPORT_URL=\u0026#34;http://help.ubuntu.com/\u0026#34; BUG_REPORT_URL=\u0026#34;http://bugs.launchpad.net/ubuntu/\u0026#34; UBUNTU_CODENAME=xenial   确认好这些信息后，从官网上下载对应的安装文件，这里选择下载是runfile(local)文件。\n下载完成后，确认文件是否完整：\n1 2  $ md5sum cuda_8.0.61_375.26_linux.run 33e1bd980e91af4e55f3ef835c103f9b cuda_8.0.61_375.26_linux.run   预处理 删除之前安装的关于nvidia的软件\n1  $ sudo apt-get purge nvidia-cuda*   如果想安装显卡驱动的话，则采用下面的命令:\n1  $ sudo apt-get purge nvidia-*   安装Nvidia显卡驱动  更新系统  1 2 3  $ sudo apt-get update $ sudo apt-get upgrade $ sudo apt-get dist-upgrade   添加Nvidia显卡驱动源  1  $ sudo add-apt-repository ppa:graphics-drivers/ppa   运行该命令会警告是否添加，按回车继续即可。\n更新系统源  1  $ sudo apt-get update   通过Ctrl+Alt+F2进入终端界面； 停止使用图形界面:  1  $ sudo service lightdm stop   在/etc/modprobe.d/目录下新建blacklist-nouveau.conf文件，并在该文件中写入下列信息:  1 2  blacklist nouveau options nouveau modeset=0   重新生成内核initrd:  1  $ sudo update-initramfs -u   搜索最新的驱动并安装  1 2  $ apt-cache search nvidia* $ sudo apt-get install nvidia-384 # 目前为最新版本   重启  1  $ sudo reboot   安装Cuda8.0 运行安装文件cuda_8.0.61_375.26_linux.run:\n1  $ sudo sh cuda_8.0.61_375.26_linux.run --override   对于安装过程中出现的选择, 除了安装显卡驱动那个选n，其他的全部选择y。\n环境变量设置 在~/.bashrc文件最后添加下列语句\n1 2 3  # CUDA-8.0 export PATH=$PATH:/usr/local/cuda/bin export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-8.0/lib64   然后再终端执行下述语句完成环境变量的设置。\n1  source ~/.bashrc   验证安装是否成功 显示nvidia版本 1 2 3 4 5  $ nvcc --version nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2016 NVIDIA Corporation Built on Tue_Jan_10_13:22:03_CST_2017 Cuda compilation tools, release 8.0, V8.0.61   显示驱动版本以及GPU的内存信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  $ nvidia-smi Fri Aug 4 15:12:38 2017 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 375.26 Driver Version: 375.26 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | |===============================+======================+======================| | 0 TITAN X (Pascal) Off | 0000:01:00.0 On | N/A | | 23% 33C P8 12W / 250W | 224MiB / 12188MiB | 0% Default | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: GPU Memory | | GPU PID Type Process name Usage | |=============================================================================| | 0 14522 G /usr/lib/xorg/Xorg 179MiB | | 0 15124 G compiz 43MiB | +-----------------------------------------------------------------------------+   运行示例文件 进入NVIDIA_CUDA-8.0_Samples文件夹下（默认在$HOME目录下），运行make进行编译， 编译需要花费一定的时间。编译完成后，进入bin/x86_64/linux/release目录，随便找一个 可执行文件，这里选择deviceQuery,运行该文件，若得到类似于下面的结果，则表示安装无误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  $ ./deviceQuery ./deviceQuery Starting... CUDA Device Query (Runtime API) version (CUDART static linking) Detected 1 CUDA Capable device(s) Device 0: \u0026#34;TITAN X (Pascal)\u0026#34; CUDA Driver Version / Runtime Version 8.0 / 8.0 CUDA Capability Major/Minor version number: 6.1 Total amount of global memory: 12188 MBytes (12780175360 bytes) (28) Multiprocessors, (128) CUDA Cores/MP: 3584 CUDA Cores GPU Max Clock rate: 1531 MHz (1.53 GHz) Memory Clock rate: 5005 Mhz Memory Bus Width: 384-bit L2 Cache Size: 3145728 bytes Maximum Texture Dimension Size (x,y,z) 1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384) Maximum Layered 1D Texture Size, (num) layers 1D=(32768), 2048 layers Maximum Layered 2D Texture Size, (num) layers 2D=(32768, 32768), 2048 layers Total amount of constant memory: 65536 bytes Total amount of shared memory per block: 49152 bytes Total number of registers available per block: 65536 Warp size: 32 Maximum number of threads per multiprocessor: 2048 Maximum number of threads per block: 1024 Max dimension size of a thread block (x,y,z): (1024, 1024, 64) Max dimension size of a grid size (x,y,z): (2147483647, 65535, 65535) Maximum memory pitch: 2147483647 bytes Texture alignment: 512 bytes Concurrent copy and kernel execution: Yes with 2 copy engine(s) Run time limit on kernels: Yes Integrated GPU sharing Host Memory: No Support host page-locked memory mapping: Yes Alignment requirement for Surfaces: Yes Device has ECC support: Disabled Device supports Unified Addressing (UVA): Yes Device PCI Domain ID / Bus ID / location ID: 0 / 1 / 0 Compute Mode: \u0026lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) \u0026gt; deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 8.0, CUDA Runtime Version = 8.0, NumDevs = 1, Device0 = TITAN X (Pascal) Result = PASS   可能出现的问题  安装完成后，下次登录系统的时候出现循环登录而进不去图形界面。  1  这种情况一般情况下是显卡驱动不是最新版本造成的，建议安装最新版本的显卡驱动。   参考资料  https://askubuntu.com/questions/799184/how-can-i-install-cuda-on-ubuntu-16-04 http://docs.nvidia.com/cuda/cuda-installation-guide-linux/#axzz4HIBXnwyt http://www.52nlp.cn/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%BB%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-ubuntu-16-04-nvidia-gtx-1080-cuda-8#comments  ","permalink":"https://blog.nickwhyy.top/post/cuda/","tags":["GPU","Cuda","Ubuntu"],"title":"Linux 下安装 CUDA"},{"categories":["地震学软件"],"contents":"背景介绍 Madagascar自带的一共有15种字体，这些字体文件位于$RSFSRC/pens/fonts，通过编译最后得到的字体二进制文件位于$RSFSRC/build/pens/fonts下，后缀为.bin。且该目录十分重要，需要在环境变量中进行设置，否则绘图的时候会出现找不到该字体的现象。\n环境变量设置 编辑$RSFROOT/share/madagascar/etc/env.sh或$RSFROOT/share/madagascar/etc/env.csh,根据自己所使用的shell决定。在该文件最后添加下列语句\n1  export VPLOTFONTDIR=$RSFSRC/build/pens/fonts/   然后再终端执行下述语句完成环境变量的设置。\n1  source ~/.bashrc   使用 改变字体 1 2 3  Plot(\u0026#39;example\u0026#39;,fdmod.cgrey(\u0026#39;font=1\u0026#39;),par) # font=[1,15] 选择不同的字体，默认应 # 该是3,近年来文章中出现的比较多的是1和2．   输入特殊字符 1 2 3 4  Plot(\u0026#39;examples\u0026#39;,fdmod.cgrey(\u0026#39;wantscalebar=y font=1 bias=0 color=e allpos=n min1=.5 formatbar=%3.0f barlabel=\u0026#34;\\s150 \\\\F10 \\\\v104 \\\\F10 \u0026#34; color=e\u0026#39;,par)) # F10为greekc字符集，v104查表可知为eta符号 # 注意一定要用`\\\\`，第一个表示转义，这样在命令行中出现的是\\F10 # 如果在命令行中输入的话，用`\\`即可   特殊字符表 在线浏览 见Madagascar官方博客\n本地浏览 $ cd $RSFSRC $ cd pens/tests $ scons  运行完上述命令后，在$RSFSRC/pens/tests/Fig目录下会出现很多.vpl文件。接着我们把font*.vpl 转化为font*.pdf，便于本地浏览。\n$ vpconvert font*.vpl format=pdf  至此，我们可以在本地浏览各种 font 字体了。感兴趣的同学也可以自己看看该目录下的其他字体。\n修订历史  2017-07-26：初稿； 2017-08-13：增加本地浏览部分；  ","permalink":"https://blog.nickwhyy.top/post/rsf-fonts/","tags":["Font","Madagascar","绘图"],"title":"Madagascar绘图字体以及特殊符号的处理"},{"categories":["安装"],"contents":"下载 Scotch最新版本目前为 6.0.6， 下载地址为：https://gforge.inria.fr/projects/scotch\n安装依赖包 安装scotch依赖于make工具以及lex和yacc，可以通过如下命令确定自己的系统是否包含上述工具。\n1 2 3  $ make --version $ which lex $ which yacc   如果没有，可以通过apt包管理系统进行安装\n1 2 3  $ sudo apt install make $ sudo apt install flex # install lex $ sudo apt install bison # install yacc   Configuration 1.在src/目录下创建Makefile.inc文件，根据自己系统安装的 C 编译器进行选择。 如果您的系统是x86_64构架的，而且也安装了icc编译，可以将Make.inc/目录下对应的Makefile.inc复制过来或者建立软链接：\n1 2  $ cd src $ ln -s Make.inc/Makefile.inc.x86-64_pc_linux2.icc Makefile.inc   如果您的系统是x86_64构架的，而且安装的是gcc编译，可以将Make.inc/目录下对应的Makefile.inc复制过来或者建立软链接：\n1 2  $ cd src $ ln -s Make.inc/Makefile.inc.x86-64_pc_linux2 Makefile.inc   安装 scotch 一旦您建立了自己的Makefile.inc文件，那么安装scotch只是一个很简单的命令\n1  $ make scotch #将scotch安装在src/上一级目录下   安装 ptscotch 安装ptscotch首先需要MPI环境，因此需要安装MPICH或OPENMPI。安装MPICH的步骤点击这里，安装OPENMPI的步骤可参考SeisMan。 有了MPI环境后, 需要对刚才新建的Makefile.inc进行修改，由于文件比较小，这里贴上我修改过的Makefile.inc文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  EXE\t= LIB\t= .a OBJ\t= .o MAKE\t= make AR\t= ar ARFLAGS\t= -ruv CAT\t= cat CCS\t= icc CCP\t= mpicc CCD\t= icc INC = /opt/mpich3.2/include # 新增此行， 根据自己MPICH的安装目录修改 CFLAGS\t= -O3 -I$(INC) -DCOMMON_FILE_COMPRESS_GZ -DCOMMON_PTHREAD -DCOMMON_RANDOM_FIXED_SEED -DSCOTCH_RENAME -DSCOTCH_PTHREAD -DIDXSIZE64 # 去掉了 -restrict 选项，不然编译会报错 CLIBFLAGS\t= LDFLAGS\t= -lz -lm -lrt -pthread -lirc # 新增 INTEL 的 irc 库文件，不然编译会报错 CP\t= cp LEX\t= flex -Pscotchyy -olex.yy.c LN\t= ln MKDIR\t= mkdir MV\t= mv RANLIB\t= ranlib YACC\t= bison -pscotchyy -y -b y   修改上述地方后，$ make ptscotch 进行ptscotch的安装。\n检查是否安装成功 1  $ make check   修订历史  2017-05-22：初稿 2019-01-03：更新 scotch 版本为 6.0.6  ","permalink":"https://blog.nickwhyy.top/post/scotch/","tags":["SCOTCH"],"title":"Linux 下安装 SCOTCH"},{"categories":["地震学软件"],"contents":"为什么要输出日志文件？ 输出日志文件的目的就是保存整个程序执行过程的所有状态信息，以便未来排错或者对结果进行分析的一种手段。\n程序运行时有些信息如程序运行时间，剩余运行时间等一般情况下需要打印在屏幕上，以便使用者能预估程序运行时间。另外一些信息如具体的参数信息，某个变量的输出值等信息可以既打印在屏幕上，同时又输出到日志文件中，方便以后对其进行分析处理。\n命令行下处理 命令行下执行Madagascar命令并将输出信息打印至日志文件的方式比较简单，可采用如下方式\n1  sfmycode \u0026lt; in1.rsf out1=out1.rsf 2\u0026gt; log.txt   2\u0026gt; log.txt　表示将程序里的其他输出语句如printf(stderr,\u0026quot;t= \\n\u0026quot;,t),sf_warning()等输出到日志文件中。\nSCons脚本处理 当采用SCons脚本来运行程序并打印相关的数据至日志文件的时候,需要进行如下处理。\n1 2 3 4 5 6  Flow(\u0026#39;out1 \u0026#39;,\u0026#39;in1.rsf\u0026#39;, \u0026#39;\u0026#39;\u0026#39; sfmycode out=${TARGET[0]} 2\u0026gt; \u0026#34;log.txt\u0026#34; \u0026#39;\u0026#39;\u0026#39;,stdout=-1)   stdout=-1表示标准输出设备未指向任何文件指针。\n注意：文件输出的选择，此时不要选择将stdout作为文件的输出指针(即在源代码中不要出现像Fout = sf_output(\u0026quot;out\u0026quot;)这样的语句)，这样的话就无法完成分别输出不同信息至屏幕和日志文件的目的。\n","permalink":"https://blog.nickwhyy.top/post/rsf-print-log/","tags":["Madagascar"],"title":"Madagascar输出程序运行日志文件"},{"categories":["地震学软件"],"contents":"正常情况下， 执行完Madagascar命令后的二进制数据文件是存在/var/tmp/下的，实际我们在写自己就的项目的时候，一般最好是把数据文件和项目存在一起，这样管理起来比较方便。因此需要了解Madagascar存储文件时选择DATAPATH的优先级关系。具体见官方说明文档 http://www.ahay.org/wiki/Guide_to_RSF_file_format。\n简述如下：\n 查看命令行是否含--out=XXX参数，如果有，则按其指定的方式进行存储，没有则继续进行下面的操作 查看命令行是否含datapath=XXX参数，如果有，则按按其指定的路径进行存储，没有则继续进行下面的操作 查看当前路径下是否含.datapath文件，如果有，则按该文件内指定的路径进行存储，没有则继续进行下面的操作 查看当前用户的根目录下是否含.datapath文件，如果有，则按该文件内指定的路径进行存储，没有则继续进行下面的操作 查看系统的环境变量是否含DATAPATH变量，如果有，则按该环境变量指定的路径进行存储，没有则继续进行下面的操作 以上都没有的话，会直接将二进制存在当前工作路径下。  因此，为了保证项目的完整型，选择第二种方式进行处理。修改$RSFROOT/share/madagascar/etc/env.sh文件中的DATAPATH变量：\n1 2  # Path for binary data files part of RSF datasets export DATAPATH=./   最后在终端运行source ~/.bashrc即可。\n修订历史  2016.12.02: 初稿； 2020.09.21： 新增修改环境变量模式；  ","permalink":"https://blog.nickwhyy.top/post/rsf-datapath/","tags":["Madagascar"],"title":"DATAPATH 的使用"},{"categories":["Linux"],"contents":"问题 复制一个文件到多个文件夹中\n解决方案 1 2  $ echo ~/test1 ~/test2 | xargs -n 1 cp -v test.py   上面的命令，目录的路径(~/test1,~/test2)被管道作为输入到xargs命令中， 含义是:\n -n 1告诉xargs命令每个命令行最多使用一个参数，并发送到cp命令中; cp用于复制文件; -v启用详细模式来显示更多细节  执行的结果如下\n1 2 3 4  $ echo ~/test1 ~/test2 | xargs -n 1 cp -v test.py \u0026#39;test.py\u0026#39; -\u0026gt; \u0026#39;/home/nick/test1/test.py\u0026#39; \u0026#39;test.py\u0026#39; -\u0026gt; \u0026#39;/home/nick/test2/test.py\u0026#39;   ","permalink":"https://blog.nickwhyy.top/post/2016-12-17-cp-command/","tags":["Linux"],"title":"Linux下复制单个文件到多个文件夹"},{"categories":["地震学软件"],"contents":"前言 当我们在 Madagascar API框架上写完自己的代码后，对于简单的程序，可以采用在源文件中增加printf或者write语句等打印一些变量信息，但比较麻烦的是每次增加一些printf等语句后，需要重新编译源代码，造成不必要的麻烦。因此，这里简单的介绍如何使用gdb来debug Madagascar程序。\n安装gdb 首先，需要查看自己的计算机是否安装了gdb软件，我们采用which命令。\n$ which gdb  如果终端中返回gdb可执行二进制文件的目录则表示已安装gdb，若提示找不到该命令则需要安装gdb。安装比较简单，输入下面语句即可安装gdb\n$ sudo apt-get install gdb  使用 安装完gdb后，我们首先进入自己编写的Madagascar程序的源文件目录，编译该代码生成可执行二进制文件。 假设我们的这个代码是实现对两个.rsf文件进行相加，最终得到二者之和。生成的可执行二进制文件名为sfadd,那么我们可以通过如下方式对其debug.\n首先在终端输入$ gdb ./sfadd进入debug模式。在终端中表现为如下结果：\n(gdb)  由于该代码需要接收两个.rsf文件作为其args。这里假设两个文件分别为add1.rsf,add2.rsf,输出的结果文件为add.rsf.那么接着在gdb中，继续键入参数信息：\n(gdb) set args \u0026quot;file1=add1.rsf\u0026quot; \u0026quot;file2=add2.rsf\u0026quot; \u0026quot;out=add.rsf\u0026quot;  这个命令通过set args来传递args信息，之后我们可以通过show args来确认参数信息。\n(gdb) show args Argument list to give program being debugged when it is started is \u0026quot;file1=add1.rsf\u0026quot; \u0026quot;file2=add2.rsf\u0026quot; \u0026quot;out=add.rsf\u0026quot; (gdb)  说明: 1.所有的参数文件必须与二进制可执行文件在同一文件夹下，如果不在，则需要显式给出其路径 2.args中的file1,file2是对应自己Madagascar程序中参数文件名，根据自己的设置修改\n最后，我们可以在gdb中输入run来跑自己的程序，还有一些其他的操作，比如设置断点以及打印变量等与正常调用gdb一致，这里不再赘述。大家可以参考在线gnu的gdb文档，里边有非常详细的介绍。\n","permalink":"https://blog.nickwhyy.top/post/2016-06-23-debug-in-rsf/","tags":["Madagascar","gdb"],"title":"Debug Madagascar程序"},{"categories":["地震学软件"],"contents":"Why? 我们都知道 Madagascar 的数据和道头是放置在不同的位置，然后在道头里通过指针指向数据文件的实际位置。这样做的好处有一下几点:\n 误删文件不会造成实际数据的丢失 本地移动文件的实际移动的只是道头，这样可以实现快速复制或者剪切整个文件夹 \u0026hellip;  因此，在大多数时候这种机制都是非常方便我们操作和处理文件及数据。但有些时候我们需要将道头和数据放置在一起，类似于.su或.segy格式，从而保证数据的完整性。比如，我们在服务器计算叠前偏移，最后得到一个偏移结果，然后需要将结果备份到本地做进一步的分析和处理(画图等),这时候就需要数据是完整的。\nHow? 对于一个.rsf文件，有几种方式可以达到这一目的。Madagascar 的官方说明文档写的是在处理数据的时候直接加一个输出选项就可以实现这一功能。该例子如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  $ sfspike n1=10 --out=stdout \u0026gt; spike.rsf $ grep in spike.rsf Binary file spike.rsf matches $ sfin spike.rsf spike.rsf: in=\u0026#34;stdin\u0026#34; esize=4 type=float form=native n1=10 d1=0.004 o1=0 label1=\u0026#34;Time\u0026#34; unit1=\u0026#34;s\u0026#34; 10 elements 40 bytes ``` 但如果处理的时候没有使用`--out=stdout`选项，那么如何将道头和数据打包在一起呢？对于上面这个例子只需要重新写一个命令加上`--out=stdout`选项就行了，因为运行时间短，这样最快捷最简便。但是如果对于某些生成最终结果需要很长时间的文件，这种方法显然显得不合时宜。这时候可以 Madagascar 的`sfcp`命令。假设我们通过下面的命令生成了一个`.rsf`文件 $ sfspike n1=10 \u0026gt;spike.rsf 然后，我们可以通过`sfin`来查看`spike.rsf`文件的道头信息以及数据文件的位置。 ```{.console} $ sfin spike.rsf in: in=\u0026#34;/var/tmp/spike.rsf@\u0026#34; esize=4 type=float form=native n1=10 d1=0.004 o1=0 label1=\u0026#34;Time\u0026#34; unit1=\u0026#34;s\u0026#34; 10 elements 40 bytes   从上面的结果可以看出spike.rsf的数据文件是/var/tmp目录下spike.rsf@文件。如果安装了 Seismic Unix 的话，还可以通过xwigb命令来绘制这个结果。\n$ xwigb \u0026lt;/var/tmp/spike.rsf@ n1=10  下面采用sfcp来合并道头和数据，命令如下:\n$ sfcp \u0026lt;spike.rsf --out=stdout \u0026gt;spikenew.rsf  现在我们通过sfin来查看spikenew.rsf的数据文件位置\n1 2 3 4 5 6 7  $ sfin \u0026lt;spikenew.rsf in: in=\u0026#34;stdin\u0026#34; esize=4 type=float form=native n1=10 d1=0.004 o1=0 label1=\u0026#34;Time\u0026#34; unit1=\u0026#34;s\u0026#34; 10 elements 40 bytes   这时候我们发现数据和道头文件合并在一起了(in=\u0026quot;stdin\u0026quot;).相信大家会有种上当受骗的感觉，想想这不还是用到了官方中说的那个选项--out=stdout么？因此，通过这个例子可以发现，几乎任何一个 Madagascar 的命令都可以实现这样的操作，但sfcp应该是比较合理的了，因为它只是单纯的复制文件而已，如果要使用一些其他命令的话，可能会出现一些奇怪的事情，大家可以尽情尝试。\n","permalink":"https://blog.nickwhyy.top/post/2016-06-15-rsf-data-handle/","tags":["Madagascar"],"title":"合并 Madagascar 道头与数据"},{"categories":["地震学"],"contents":"本文主要用于收集一些免费的数据来源。将不定期更新新的数据源。\nMadagascar 数据：http://www.ahay.org/data/\nSEG Research Data: http://seg.org/News-Resources/Research-Data\nCREWES 公开的数据 NMESdata.zip : https://www.crewes.org/ResearchLinks/FreeSoftware/\nSAIG 公开的数据 : http://seismic.physics.ualberta.ca/data/\nSeismicLab 里面自带部分数据: http://seismic-lab.physics.ualberta.ca/\nHIT 公开的数据: http://pan.baidu.com/s/1qYwI1IG\nOpen Seismic Repository: http://opendtect.org/osr/\nEquinor 公开的数据(几乎涵盖了勘探领域的所有研究方向的数据)：https://www.equinor.com/en/how-and-why/digitalisation-in-our-dna.html\nIEDA: Marine Geoscience http://www.marine-geo.org/tools/search/Files.php?data_set_uid=24554\nfree USP: 2D_Land_data_2ms.tgz https://www.freeusp.org/RaceCarWebsite/TechTransfer/Tutorials/Processing_2D/Data\nOBS data: http://www.jamstec.go.jp/obsmcs_db/e/data-e/\n","permalink":"https://blog.nickwhyy.top/post/2016-06-09-data-resources/","tags":["数据"],"title":"勘探数据获取"},{"categories":["地震学软件"],"contents":"最开始使用 SU 的时候，写脚本文件是个比较令人头疼的问题。因为 SU 下给的例子都是普通的 bash 脚本，存在以下问题：\n  bash 脚本是按顺序执行的，也就是说，如果你在脚本的最后几句有一个绘图命令的话，那么第一次执行脚本的时候可以处理前面的一些工作流程，然后再绘图。如果后面我们觉得结果已经很完美了，但图片的大小或者标题什么需要修改一下，那么当我们修改绘图命令后再次运行脚本的话，会把前面的整个工作流程再重复一遍，这将浪费很多时间。\n  bash 脚本对计算的支持很弱，如果不使用一些工具的话，没法进行浮点数运算。\n  对于问题 1，可以单独将绘图命令拿出来另写一个脚本文件解决，但会使得文件目录下脚本文件过多，不便于文件的整理。其次，假设我们有一个脚本文件，里边有 5 行命令用来处理数据，如果我们改变了第 3 行的命令行参数，那么再次运行脚本，仍会继续执行第 1 条和第 2 条命令，那为了避免浪费时间，我们也得把剩下的第 3-5 条命令单独拿出来写入一个新的脚本？\n对于问题 2，目前是没有更好的办法解决的，只能使用 bash 的 bc 计算功能，但其表达式书写繁琐，不易搞懂。\n针对以上问题，Madagascar 提供了更好的解决方案，使得我们可以 借用 SCons 工具来写 SU 的脚本。模板如下\n1 2 3 4 5 6 7  import rsf.suproj as sp # creat a common offset data file sp.Flow(\u0026#39;plane\u0026#39;,None,\u0026#39;suplane\u0026#39;,stdin=0) # creat a wigb type plot sp.Plot(\u0026#39;plane\u0026#39;,\u0026#39;supswigb\u0026#39;) sp.End()   上述脚本实际上是 SU 安装是否成功的一个简单的测试例子,这里将 rsf.proj模块导入并命名为surun，大家可以更改为不同的名字，主要目的是为了在同一文件中既写 SU 的脚本，也写 Madagascar 的脚本。需要注意的是上述脚本创建了一个plane.su的文件，然后通过surun.Plot命令创建了plane.eps的矢量图片文件。因为 SCons 总是将不含后缀的文件自动加上.su的后缀。而并不是所有的 SU 程序都生成.su后缀的文件，比如速度建模程序unif2，因此，对于 SU 的 SCons 脚本书写规范，建议最好对于输入和输出文件都显示的给出文件后缀。总结一下就是：\n 含以su开头的 SU 命令的 Flow 语句，文件的输出统一加上.su后缀 含不以su开头的 SU 命令的Flow 语句，文件的输出统一加上.bin后缀  ","permalink":"https://blog.nickwhyy.top/post/su-scons-together/","tags":["SConstruct","SU"],"title":"采用 SConstruct 写 SU 脚本"},{"categories":["编程"],"contents":"Vim高亮文件一般只对含后缀的文件名有效，对于经常使用 Madagascar 的人来说，每次采用 Vim 写 SConstruct 文件显得十分不便，因此如果能让 Vim 自动识别 SConstruct 文件为 Python 文件，则处理起来会很方便.\n方法一 对于 SCons 要编译的文件，不命名为 SConstruct, 而命名为SConstruct.py，然后用 SCons 编译，这样的好处是用其他的编辑器打开也是Python的文本高亮模式。\n方法二 每次打开 SConstruct 文件后进入 Vim 命令行模式将文件类型设置为 Python 。\n1  :set ft=python   方法三 在~/.vimrc文件中指定所有的 SCons 相关的文件类型为 python，可直接在~/.vimrc文件末尾添加下列语句即可达成目标\n1 2  \u0026#34; Filetype related au BufNewFile,BufRead SConstruct,sconstruct,SConscript,sconscript set ft=python   ","permalink":"https://blog.nickwhyy.top/post/vim-scons-highlight/","tags":["SConstruct","Vim"],"title":"Vim 高亮 SConstruct"},{"categories":["地震学软件"],"contents":"之前一直尝试在 Madagascar 下使用 latex 功能，但一直没有实现。也没有太多地时间来研究这个。今天，实在是忍不住了，开始重新研究起来。首先，cd到book目录下，任选一个文件夹进去，然后运行$ scons，发现总是出现权限不够错误。后来再进入到其他文件夹，发现还是存在同样的问题。但这次发现问题的根源所在了。\nMadagascar 下使用 scons 来编译 latex 将会在$RSFROOT/share/madagascar下创建一个本地文件夹的副本，其目的是为了用来之后lock图片所用，而由于不管将 Madagascar 安装在/opt下，还是$HOME下的某个目录，$RSFROOT都默认不是 766 权限。因此其下的share/madagascar也一样。通过测试发现，只有share/madagascar为 766 权限时，madagascar 才能向里边写文件.因此第一步就是将该路径设置为 766 .\n按上述设置后，scons 暂时不报错了，也可以正常编译 latex 文件，但是由于 madagascar 下的 tex 基本是与地球物理相关的，因此 latex 下的 texmf 缺少一些 cls 文件，可从 sourceforge 上下载 segtex ，然后将源码解压并放在$HOME/texmf下，然后通过texhash来将其添加到现有的 latex 的 texmf 中。\n虽然，按上述操作后 latex 也不报错了，但 latex 编译完后，scons 还是会报一些小的错误，主要是关于阅读和打印 pdf 的问题，因为采用 tex.py 中的 Paper 来编译 latex 文件时，编译完会自动打开并打印文件，而在其打印机下并未写打印机名称以及地址，因此总会报错，毕竟这是一个 machine-depending 的问题， Madagascar 没有处理好这个问题是很正常的。这算是 Madagascar 的一个小 bug 。但并不影响读者正常编译和使用。\n但笔者还是要解决这个问题，因为并不是每个人编译完文件都想马上打开 pdf 文件，也没有这个必要这么做，因此，我们找到$RSFROOT中的 tex.py 文件，注释掉其中的两行代码，就可解决上述问题。\n至于 latex 编译时会遇到系统中缺少一些字体的情况，并不是本文讨论的重点。大家可自行谷歌予以解决。\n","permalink":"https://blog.nickwhyy.top/post/2016-05-24-rsf-use-latex/","tags":["Madagascar","LaTeX","Paper"],"title":"Madagascar下使用 LaTeX"},{"categories":["安装"],"contents":"下载 下载链接:https://seiscope2.obs.ujf-grenoble.fr/TOY2DAC,82\n编译 将下载的软件解压后，进入doc/目录下，查看manual文档进行编译。\n依赖包安装 安装TOY2DAC需要MUMPS来进行大型稀疏矩阵的LU分解，而MUMPS又要安装METIS或者SCOTCH，同时，编译MUMPS来依赖 SCALAPACK, BLACKS, LAPACK 三个依赖库文件，好在这些都在Intel的MKL库中集成，因此实际上只需要安装Intel编译器，MPI，METIS，MUMPS。这几个软件的安装可参考如下链接：\n Intel编译器 MPI库 METIS MUMPS  修改Makefile.inc 安装完上述依赖包后，进入src/，找到Makefile.inc文件并编辑该文件，需要修改上述库文件的LIB和INC为其安装目录。原文件需要改动的地方不多。笔者主要修改了如下几处：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #ROOT DIR OF MUMPS/METIS LADIR = ~/software #ROOT DIR OF TOOL BOX LTOOLS_BOX = ~/software/TOOLBOX_OPTIMIZATION #MUMPS LIB AND INC LMUMPS = -L$(LADIR)/MUMPS_5.1.1/lib -lcmumps -lmumps_common IMUMPS = -I$(LADIR)/MUMPS_5.1.1/include #PORD LIB (INSIDE MUMPS) LPORDDIR = $(LADIR)/MUMPS_5.1.1/PORD/lib/ LPORD = -L$(LPORDDIR) -lpord #METIS LIB LMETISDIR = $(LADIR)/metis/lib LMETIS = -L$(LMETISDIR) -lmetis #TOOL BOX LIB AND INC LOPTIM = -L $(LTOOLS_BOX)/lib -lSEISCOPE_OPTIM IOPTIM = -I $(LTOOLS_BOX)/COMMON/include #WE GATHER EVERYTHINGS LIBPAR = $(LMUMPS) $(LPORD) $(LOPTIM) $(LMETIS) $(LMKL) INCPAR = $(IMUMPS) $(IPORD) $(IOPTIM) -I../include INC = $(INCPAR) LIB = $(LIBPAR)   Compilation 在src/目录下，运行 make，便完成整个编译过程\n","permalink":"https://blog.nickwhyy.top/post/toy2dac/","tags":["toy2dac","FWI"],"title":"Linux 下安装 TOY2DAC"},{"categories":["安装"],"contents":"下载 下载链接: https://seiscope2.obs.ujf-grenoble.fr/SEISCOPE-OPTIMIZATION-TOOLBOX\n编译 将下载的软件解压后，进入doc/目录下，查看manual文档进行编译。\n修改Makefile.inc Makefile.inc文件位于根目录下，只需要修改与自己系统相适的编译器即可，一般情况不用作任何改动，因为其默认使用的是intel的编译器。\nCompilation 在根目录下，运行\n1  $ make lib   即可在目录lib/下生成libSEISCOPE_OPTIM.a,该文件对于后面安装TOY2DAC十分有用。\n","permalink":"https://blog.nickwhyy.top/post/toolbox-optimization/","tags":["toolbox"],"title":"Linux 下安装 TOOLBOX-OPTIMIZATION"},{"categories":["安装"],"contents":"下载 下载,需要上下面的网站去预留信息，然后开发者会在几小时内将软件发至你留的邮箱中，建议下载最新版本5.1.1。\n源码：http://graal.ens-lyon.fr/MUMPS/ , 如果该链接无法访问，请访问 https://launchpad.net/ubuntu/+source/mumps/5.1.1-2 , 该网页中有个名为mumps_5.1.1.orig.tar.gz,下载该文件即可。\n基本依赖包 安装MUMPS有三种方式，一种是只安装单核版(sequential version);一种是安装多核版(multicore machine)；最后一种是并行版(parallel version).由于笔者安装MUMPS的主要目的是用于FWI，因此对于运行速度要求很高，在此选择并行版进行安装。其它方式的安装比较简单，读者可自行尝试。\n安装并行版MUMPS需要以下一些依赖包\n  MPI\n  BLAS library\n  BLACS library\n  ScaLAPACK library\n  其中 MPI 一般有两种 MPICH 和 OPENMPI, 安装 MPICH 请点击这里；至于BLAS，BLACS，ScaLAPACK 这三个库可使用 Intel 的 MKL 库，因此需要安装 intel 的编译器，请点击这里。\n解压 1 2  $ tar zxvf MUMPS_5.1.1.tar.gz $ cd MUMPS_5.1.1   修改Makefile.inc 安装好intel编译器后，在此可直接复制 Make.inc/ 目录下的 Makefile.INTEL.PAR 文件至 MUMPS 的根目录，并修改一些参数使之与自己的系统相符。\n1  $ cp Make.inc/Makefile.INTEL.PAR ./Makefile.inc   由于 MUMPS 需要依赖与 METIS 或 SCOTCH 来划分网格，两种选一种即可，此处选择的是 METIS，下载 METIS 并编译好 METIS 后，需要修改刚才的Makefile.inc文件，具体改动如下：\n去掉LMETISDIR和LMETIS前的注释，并根据自己METIS的安装情况给其赋值，然后，在添加-Dmetis在ORDERINGSF之后。 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  # # This file is part of MUMPS 5.1.1, released # on Mon Mar 20 14:34:33 UTC 2017 # #Begin orderings  # NOTE that PORD is distributed within MUMPS by default. It is recommended to # install other orderings. For that, you need to obtain the corresponding package # and modify the variables below accordingly. # For example, to have Metis available within MUMPS: # 1/ download Metis and compile it # 2/ uncomment (suppress # in first column) lines # starting with LMETISDIR, LMETIS # 3/ add -Dmetis in line ORDERINGSF # ORDERINGSF = -Dpord -Dmetis # 4/ Compile and install MUMPS # make clean; make (to clean up previous installation) # # Metis/ParMetis and SCOTCH/PT-SCOTCH (ver 6.0 and later) orderings are recommended. #  #SCOTCHDIR = ${HOME}/scotch_6.0 #ISCOTCH = -I$(SCOTCHDIR)/include # # You have to choose one among the following two lines depending on # the type of analysis you want to perform. If you want to perform only # sequential analysis choose the first (remember to add -Dscotch in the ORDERINGSF # variable below); for both parallel and sequential analysis choose the second # line (remember to add -Dptscotch in the ORDERINGSF variable below)  #LSCOTCH = -L$(SCOTCHDIR)/lib -lesmumps -lscotch -lscotcherr #LSCOTCH = -L$(SCOTCHDIR)/lib -lptesmumps -lptscotch -lptscotcherr  LPORDDIR = $(topdir)/PORD/lib/ IPORD = -I$(topdir)/PORD/include/ LPORD = -L$(LPORDDIR) -lpord ################## 修改部位1 ################### LMETISDIR = $(HOME)/software/metis/lib IMETIS = $(HOME)/software/metis/include ###############################################  # You have to choose one among the following two lines depending on # the type of analysis you want to perform. If you want to perform only # sequential analysis choose the first (remember to add -Dmetis in the ORDERINGSF # variable below); for both parallel and sequential analysis choose the second # line (remember to add -Dparmetis in the ORDERINGSF variable below)  ################## 修改部位2 ################### LMETIS = -L$(LMETISDIR) -lmetis #LMETIS = -L$(LMETISDIR) -lparmetis -lmetis ###############################################  # The following variables will be used in the compilation process. # Please note that -Dptscotch and -Dparmetis imply -Dscotch and -Dmetis respectively. # If you want to use Metis 4.X or an older version, you should use -Dmetis4 instead of -Dmetis # or in addition with -Dparmetis (if you are using parmetis 3.X or older).  ################## 修改部位3 ################### #ORDERINGSF = -Dscotch -Dmetis -Dpord -Dptscotch -Dparmetis ORDERINGSF = -Dpord -Dmetis ORDERINGSC = $(ORDERINGSF) ###############################################  LORDERINGS = $(LMETIS) $(LPORD) $(LSCOTCH) IORDERINGSF = $(ISCOTCH) IORDERINGSC = $(IMETIS) $(IPORD) $(ISCOTCH) #End orderings ######################################################################## ################################################################################  PLAT = LIBEXT = .a OUTC = -o OUTF = -o RM = /bin/rm -f CC = mpiicc FC = mpiifort FL = mpiifort AR = ar vr #RANLIB = ranlib RANLIB = echo # Make this variable point to the path where the Intel MKL library is # installed. It is set to the default install directory for Intel MKL. MKLROOT=/opt/intel/mkl/lib/intel64 LAPACK = -L$(MKLROOT) -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core SCALAP = -L$(MKLROOT) -lmkl_scalapack_lp64 -lmkl_blacs_intelmpi_lp64 LIBPAR = $(SCALAP) $(LAPACK) INCSEQ = -I$(topdir)/libseq LIBSEQ = $(LAPACK) -L$(topdir)/libseq -lmpiseq LIBBLAS = -L$(MKLROOT) -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core LIBOTHERS = -lpthread #Preprocessor defs for calling Fortran from C (-DAdd_ or -DAdd__ or -DUPPER) CDEFS = -DAdd_ #Begin Optimized options OPTF = -O -nofor_main -qopenmp # or -openmp for old compilers OPTL = -O -nofor_main -qopenmp OPTC = -O -qopenmp #End Optimized options  ################## 修改部位4 ################### INCS = $(INCPAR) -I$(IMETIS) ###############################################  LIBS = $(LIBPAR) LIBSEQNEEDED =   Compilation 1  $ make alllib   编译完成后，可以在MUMPS的安装目录下发现有目录lib/,该目录主要用于链接外部函数调用此库文件。\n  运行 make alllib 之后，可能会报错，错误信息为\u0026rsquo;ar: two different operation options specified\u0026rsquo;，其主要原因在于 Makefile.inc 文件中 AR 变量的设置存在问题。需要在后面补充一个空格符，即可完成正常安装。\n","permalink":"https://blog.nickwhyy.top/post/mumps/","tags":["MUMPS"],"title":"Linux 下安装 MUMPS"},{"categories":["安装"],"contents":"下载 选择最新版本(5.1.0)进行下载：\n源码链接：http://glaros.dtc.umn.edu/gkhome/metis/metis/download\n基本依赖包   C compiler，比如 gcc\n  GNU make ,一般Linux系统自带\n  Cmake 2.8以上\n  修改头文件(可选) 修改include/metis.h文件中的IDXTYPEWIDTH，来指定系统浮点位宽，32bit 系统只能选择32, 64bit 系统即可选择32，也可选择64.具体根据自己需求决定\nCompilation 1 2  $ make config shared=1 cc=gcc prefix=/where/to/install/metis $ make install   编译完成后，可以在METIS的安装目录下发现有目录lib/,该目录主要用于链接外部函数调用此库文件。\n","permalink":"https://blog.nickwhyy.top/post/metis/","tags":["METIS"],"title":"Linux 下安装 METIS"},{"categories":["安装"],"contents":"下载 要下载SPECFEM2D，可以在终端中输入以下命令：\n1  $ git clone --recursive --branch devel https://github.com/geodynamics/specfem2d.git   安装 安装SPECFEM 2D需要安装\n ifort编译器，可使用 gfortran 代替。 mpi并行环境，可安装不带 MPI 加速的版本 scotch，安装SPECFEM3D时会自动安装其目录下绑定的scotch版本，但版本不是最新版本  有了上述工具之后，我们可以进入specfem2d的根目录进行安装。\n安装不带MPI的版本 1 2  $ ./configure FC=ifort --without-mpi $ make   安装带MPI的版本 1 2  $ ./configure FC=ifort MPIFC=/opt/mpich3.3/bin/mpif90 MPI_INC=/opt/mpich3.3/include --with-mpi $ make     注意：这里最好显式地给出mpif90的路径，不然编译的时候会调用系统里 安装的其他mpif90,然后就是给出MPI的include变量MPI_INC，编译 的时候会用到mpi.h头文件，所以需要从MPI_INC里找。\n安装带 MPI 且使用非 SPECFEM2D 绑定的 scotch 版本 和安装带 MPI 的版本的差不多，只不过，采用的是下面的configure\n1 2  $ ./configure FC=ifort MPIFC=/opt/mpich3.3/bin/mpif90 MPI_INC=/opt/mpich3.3/include --with-mpi -with-scotch-dir=/opt/scotch_6.0.4 $ make     注意：本文给出的/opt/mpich3.3,/opt/scotch_6.0.4只是个例子， 大家根据自己 mpich 和 scotch 的安装位置进行适当修改，没有必要一定 要将 mpich 和 scotch 安装在/opt下。\n编译完成后，可以在specfem2d的根目录下发现有一个新的目录bin/,该目录下包含specfem2d的二进制可执行文件。\n修订历史  2016-05-14：初稿； 2018-08-01：更新无效的链接； 2018-11-24：指明采用ifort来进行编译； 2018-11-25：更新mpich为3.3 \u0026amp;\u0026amp; 完善安装细节；  ","permalink":"https://blog.nickwhyy.top/post/specfem2d/","tags":["SPECFEM2D"],"title":"Linux 下安装 SPECFEM2D"},{"categories":["安装"],"contents":"前言 SEPlib的源码已托管在GitLab上，具体链接为http://cees-gitlab.stanford.edu/bob/SEPlib ，为最新版本的官方源码。本文所安装的是6.5.3版本的SEPlib,最新版本的安装请参考另一篇博文。\n软件下载 下载最新版本的 SEPlib，目前为6.5.3. 实际有7.0.5，但官网上没有链接了，估计人都转向 Madagascar 了。\n下载地址： http://sepwww.stanford.edu/doku.php?id=sep:software:seplib\n安装依赖包 安装 SEPlib-6.5.3，需要一些依赖包，由于笔者之前安装过 Madagascar 以及SU，因此 大部分的依赖包基本安装完毕，但还需要安装下列依赖包:\n$ sudo apt-get install flex # lex $ sudo apt-get install libpawlib-lesstif3-dev # lesstif  这里需要注意的是lesstif包。不同版本的Debian系统可能含有的软件包不一样，具体以自己版本为主。\n基础安装 最好使用ifort来编译代码，在configure前需要显式指出下列环境变量:\n$ export CC=icc # C 编译器 $ export FC=ifort # Fortran 编译器 $ export CFCDEFINES=-DpgiFortran # 如果不设置此项，后面链接finitpar会出错  另外，一点需要注意的是，如果使用ifort来编译，运行下面的命令后，需要查看ifort是否已经设置为Fortran编译器，这点很重要，因为一般如果将 SEPlib 安装在/opt下的话，需要使用root权限，而我们一般将ifort的环境变量设置在自己的用户目录下，因此configure时检查ifort会出现没有ifort而采用系统的一些Fortran编译器。\n$ ./configure --prefix=/opt/SEPlib --with-su=/su/installed/dir --with-local  configure完成后，在终端键入下面命令，将编译 SEPlib，并将其安装至指定地文件目录下\n$ make $ make install  在编译的过程中可能出现哑元类型不匹配的问题，主要原因是因为源程序super_chain_mod.f90部分代码输入参数定义不严谨所致，修改该程序中部分代码即可解决此类问题。需要修改的部分如下所示.\ninteger function flat_chain_exec( adj, add, model, data) ! W Grad K integer ::stat logical,intent(in) :: adj, add ! 28 real :: data(:), model(:) integer function flat_chain_adj_exec( adj, add, model, data) ! K' Grad' W' integer ::stat ! logical :: adj, add,adj_new logical,intent(in) :: adj, add ! 51 logical :: adj_new ! 52 real :: data(:), model(:) integer function flat3_chain_exec( adj, add, model, data) integer ::stat logical,intent(in) :: adj, add ! 115 real :: data(:), model(:) integer function flat3_chain_adj_exec( adj, add, model, data) integer ::stat logical,intent(in) :: adj, add ! 142 logical :: adj_new ! 143  环境变量的设置 环境变量的设置，这一步是非常重要的，正确设置环境变量对以后正常使用大有裨益。在此，笔者借鉴了 Madagascar 的环境变量设置方案，可以在 SEPlib 的安装目录SEPROOT下的share目录中建立一文件夹名叫seplib（读者可自行取其他名字），根据用户自己的shell类型来创建不同的环境变量执行脚本，对于csh用户，创建env.csh；而对bash用户，则创建env.sh.下面分别给出不同的shell类型的脚本，供大家参考，至于具体目录文件的设置，根据自己的喜好设置。\ncsh文件\n#!/bin/csh # Path for SEPlib installation directory setenv SEPROOT /opt/seplib # Path for SEPlib source directory setenv SEPSRC /home/abc/seplib-6.5.3 # Path for Python packages if ($?PYTHONPATH) then setenv PYTHONPATH $SEPROOT/lib/python:${PYTHONPATH} else setenv PYTHONPATH $SEPROOT/lib/python endif # Path for binary data files part of SEP datasets # setenv DATAPATH /var/tmp/ # Path for manual pages setenv MANPATH `manpath`:$SEPROOT/man # Path for shared object files # if ($?LD_LIBRARY_PATH) then # setenv LD_LIBRARY_PATH $SEPROOT/lib:${LD_LIBRARY_PATH} # else # setenv LD_LIBRARY_PATH $SEPROOT/lib # endif # Path for executables set path = ($SEPROOT/bin $path) # Path for vplot files setenv VPLOTSPOOLDIR /var/tmp/SEP/Figs/ # Path for vplot fonts setenv VPLOTFONTDIR $SEPROOT/include # Path for SEP includedir setenv SEPINC $SEPROOT/include  bash文件\n#!/bin/sh # Path for SEPlib installation directory export SEPROOT=/opt/seplib # Path for SEPlib source directory export SEPSRC=/home/abc/seplib-6.5.3 # Path for Python packages if [ -n \u0026quot;$PYTHONPATH\u0026quot; ]; then export PYTHONPATH=$SEPROOT/lib/python:${PYTHONPATH} else export PYTHONPATH=$SEPROOT/lib/python fi # Path for binary data files part of SEP datasets # export DATAPATH=/var/tmp/ # Path for manual pages unset MANPATH export MANPATH=`manpath`:$SEPROOT/man # Path for shared object files # if [ -n \u0026quot;$LD_LIBRARY_PATH\u0026quot; ]; then # export LD_LIBRARY_PATH=$SEPROOT/lib:${LD_LIBRARY_PATH} # else # export LD_LIBRARY_PATH=$SEPROOT/lib # fi # Path for executables export PATH=$SEPROOT/bin:$PATH # Path for vplot files export VPLOTSPOOLDIR=/var/tmp/SEP/Figs/ # Path for vplot fonts export VPLOTFONTDIR=$SEPROOT/include # Path for SEP includedir export SEPINC=$SEPROOT/include  这样设置好了之后，我们需要修改自己的~/.bashrc文件,在文件最后面添加如下几句,这样环境变量就设置好了。\n# SEPlib 6.5.3 export SEPROOT=/opt/seplib source $SEPROOT/share/seplib/env.sh  修改~/.bashrc文件之后，我们只需要在当前终端键入如下命令，即可使环境变量马上生效:\n$ source ~/.bashrc  安装更多功能的SEPlib 在成功安装了不带 FFTW 以及 MPI 库的 SEPlib. 下面介绍安装一个更完整的 SEPlib。\n由于对 SEPlib 的源代码以及整个程序框架有了更进一步的了解，所以这次选择更高级一点的安装方式。首先在安装源文件的根目录执行如下命令:\n$ cp docs/config-examples/RUN_THIS.base .  然后修改该文件，整体文件不再大改，只需要根据自己的需求修改其中的某些变量即可。由于这次主要是加入 OPENMP 和 FFTW。之所以没安装 MPI 主要是因为 OPENMP 适合于共享式内存计算机。下面列出一些基本的参数设置信息\nsetenv CC gcc setenv FC ifort setenv FFTW_FCLD \u0026quot;-L/usr/lib/x86_64-linux-gnu/ -lfftw3 -lfftw3f\u0026quot; # 根据自己 FFTW 的位置修改 setenv OMP_FCFLAGS -openmp # -openmp 为 Intel 编译器的选项，其他编译器不一样，需修改成该编译器的 OPENMP 选项 setenv OMP_FCLD \u0026quot;-L/opt/intel/compilers_and_libraries_2016/linux/lib/intel64/ -liomp5 -liompstubs5\u0026quot; # 根据自己　Intel openmp 动态链接库的位置修改 ./configure --prefix=/opt/SEPlib --with-su=/su/installed/dir --with-local --with-fftw --with-omp  修改完成后，保存文件，在终端对文件添加可执行权限,并执行脚本:\n$ chmod +x RUN_THIS.base $ ./RUN_THIS.base ＃运行脚本  键入上述命令后,将会编译整个源文件，在编译的过程中遇到一些问题，主要原因是源文件的 Makefile 文件存在一些问题。这里列出本人安装过程中出现的一些错误：\nBug1: 编译Transf_fftw时出错，出现undefined reference omp_get_num_threads\n解决: 修改Transf_fftw.f90所在文件目录的 Makefile 文件，在484行末尾，即Transf_fftw_LDADD这行末尾添加${OMP_FCLD}，然后在504,506,508,511行中加入${OMP_FCFLAGS},修改完保存，再回到根目录重新$make一下就好了。上述 Bug1 在后面还有几次编译过程仍存在此问题，解决办法是找到出错的源文件位置，按照上面提到的解决方案，添加 openmp 动态链接库位置以及编译选项，即可解决此类问题。\nBug2: 编译RickMovie时会出现错误，主要是类似于undefined reference Xtadd/X11...这样的错误。\n解决: 进入RickMovie目录，修改Makefile文件，修改其中的第212行，即Rickmovie_LDADD所在那行，在其后添加-lXt -lX11即可解决此类问题，其实思路与前面omp一致，无非是没有将相关库加入编译选项中。Bug2 在后面的编译中还会遇到，主要位于Ricksep中，运用同样方法可以解决，不再赘述。\n解决完所有的Bug1、Bug2之类的错误后，后面的编译过程基本畅通无阻，$ make完之后再$ make install，即可安装完　SEPlib，最后再设置环境变量即可正常使用。\n修订历史  2016-05-13： 初稿 2019-09-17： 修改SEPlib下载链接  ","permalink":"https://blog.nickwhyy.top/post/seplibold/","tags":["SEPlib","Linux","地震学软件"],"title":"Linux 下安装 SEPlib"},{"categories":["安装"],"contents":"Seismic Unix是Colorado School of Mines开发的一款地震数据处理软件。最新的版本代号为44R2。 这里选择44R2版本进行安装。\n下载地址：https://github.com/JohnWStockwellJr/SeisUnix\n安装依赖包 1 2 3 4 5 6 7  $ sudo apt-get install build-essential $ sudo apt-get install libx11-dev $ sudo apt-get install libxt-dev $ sudo apt-get install freeglut3-dev $ sudo apt-get install libxmu-dev $ sudo apt-get install libxi-dev $ sudo apt-get install gfortran   配置环境变量 一般软件的安装都是先编译，之后配置环境变量，su不同，正好相反，需要先配置环境变量。\n向~/.bashrc中加入如下语句以配置环境变量。\n1 2 3  # Seismic Unix 44R1 export CWPROOT=$HOME/opt/cwp export PATH=$PATH:$CWPROOT/bin   注：CWPROOT为su的安装路径，请根据自己想要安装的路径确定，这里是放在了$HOME/opt/cwp。不要以root权限安装su，若造成系统不稳定，后果自负!!!\n解压 1 2 3 4 5 6  $ cd ~ $ mkdir opt $ cd opt $ mkdir cwp $ cd cwp $ git clone https://github.com/JohnWStockwellJr/SeisUnix src   编译，安装 编译前，可以选择修改一下src/Makefile.config文件。\n1 2 3 4  LINEHDRFLAG = #XDRFLAG = -DSUXDR 建议将此行注释掉，此行的目的在于将所有的su文件都变成big-endian的格式 ENDIANFLAG = -DCWP_LITTLE_ENDIAN LARGE_FILE_FLAG = -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE   1 2 3 4 5  $ cd src $ make install $ make xtinstall $ make finstall $ make mglinstall    采用新的编译器如Ubuntu 20.04中的gfortran 9.3.0来编译时，可能出现以下错误：\n 1 2 3 4 5 6  gfortran -g -ffixed-line-length-none -c ./vzestf.f -o ./vzestf.o ./vzestf.f:271:10: 271 | + fnames) | 1 Error: Actual argument contains too few elements for dummy argument ‘fnames’ (240/360) at (1)   解决方案是在src/Makefile.config文件中FFLAGS变量后面添加-std=legacy，重新运行make finstall即可。\n修订历史  2016-05-12：初稿； 2018-08-01：更新无效的链接； 2020-09-21：高版本gfortran编译器编译出错修正方案  参考资料  高版本gfortran编译器编译出错修正方案  ","permalink":"https://blog.nickwhyy.top/post/seismic-unix/","tags":["SU"],"title":"Linux 下安装 Seismic Unix"},{"categories":["安装"],"contents":"与Seismic Unix类似，Madagascar也是一款地震数据处理软件，其开发者众多，内置的软件也非常多， 缺点就是代码注释比较少，不容易懂。给的示例虽多，但也不容易懂，对于初学者而言十分困难。\n下载最新的Release版本：http://github.com/ahay/src.git\nLinux 下安装Madagascar 安装依赖包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  # 必须安装的依赖包 $ sudo apt install libxaw7-dev # 建议安装的依赖包 $ sudo apt install freeglut3-dev $ sudo apt install libnetpbm10-dev $ sudo apt install libgd-dev $ sudo apt install libplplot-dev $ sudo apt install libavcodec-dev $ sudo apt install libcairo2-dev $ sudo apt install libjpeg-dev $ sudo apt install swig $ sudo apt install python-dev $ sudo apt install python-numpy $ sudo apt install g++ $ sudo apt install gfortran $ sudo apt install libopenmpi-dev $ sudo apt install libfftw3-dev $ sudo apt install libsuitesparse-dev # 不建议安装的包 $ sudo apt install python-epydoc # 安装 octave API 需要下面的包 $ sudo apt install octave liboctave-dev   编译，安装 1 2 3 4 5  $ git clone https://github.com/ahay/src.git madagascar-2.0 $ cd madagascar-2.0 $ ./configure API=c++,f90,python,matlab,octave --prefix=/home/lloyd/rsf2.0 # 额外安装C++，Fortran, Python, Matlab, Octave 五个API $ make $ make install     若出现checking for mkoctfile ... (cached) no的错误，主要原因是缺liboctave-dev,重新安装liboctave-dev即可。\n配置环境变量 向~/.bashrc中加入如下语句以配置环境变量。\n1 2 3  # Madagascar 2.0 export RSFROOT=/home/lloyd/rsf2.0 source $RSFROOT/share/madagascar/etc/env.sh   macOS High Sierra 下安装Madagascar 安装依赖包  安装MacPorts,进官网，下载安装文件打开安装即可。 安装Xcode，从App Store里安装即可 X11，可通过安装Xquartz来获得X11，进官网下载安装文件安装即可  1 2 3 4 5 6 7 8  ## FFTW $ sudo port install fftw-3-single $ sudo port install fftw-3 +gfortran ## MPI sudo port install openmpi sudo port select --set mpi openmpi-mp-fortran ## ppmpen sudo port install libnetpbm   编译，安装 macOS 安装 Matlab API 限制比较多，首先需要在~/.bash_profile中添加 Matlab 的安装路径。\n1 2  # MATLAB 20XXX, XXX 为版本号，比如 Matlab 2018a etc. export PATH=$PATH:/Applications/MATLAB_R20XXX.app/bin   1 2 3 4  ## 在Madagascar 源码的根目录下执行下列操作 $ ./configure CC=clang CXX=clang++ API=python,f90,matlab,octave --prefix=/Users/lloyd/rsf # 额外安装C++,Python,Fortran,Matlab,Octave五个API $ make $ make install     另外，需要考虑 Matlab mex 支持的编译器，比如最新的 macOS High Sierra 系统中 Xcode 的版本为9.X，而 Matlab 2016x 等不支持该版本的编译器。关于 Matlab 版本与对应的 Xcode 版本对应关系详见： https://www.mathworks.com/support/sysreq/previous_releases.html\n配置环境变量 向~/.bash_profile中加入如下语句以配置环境变量。\n1 2 3  # Madagascar 2.0 export RSFROOT=/Users/lloyd/rsf source $RSFROOT/share/madagascar/etc/env.sh   参考  https://www.mathworks.com/support/sysreq/previous_releases.html https://www.mathworks.com/matlabcentral/answers/361388-matlab-2016b-on-mac-with-xcode-9-error  修订历史  2016-05-22: 初稿； 2017-07-18: 更新至 madagascar2.0; 2018-04-28: 更新 macOS High Sierra 下安装 Madagascar; 2018-05-20: 更新 Linux 安装 Matlab API; 2018-05-22: 更新 macOS High Sierra 下安装 Matlab API; 2018-08-12：新增 Octave API  ","permalink":"https://blog.nickwhyy.top/post/madagascar/","tags":["Madagascar"],"title":"Madagascar 的安装"},{"categories":["安装"],"contents":"DENISE是一个KIT开发的用于全波形反演的软件。\n下载 下载,需要上下面的网站去预留信息，然后开发者会在几小时内将软件发至你留的邮箱中。\n官网：http://www.gpi.kit.edu/Software-FWI.php\n安装DENISE的过程十分简单，开发者把脚本都写好了，只需要运行一下代码就可以编译成功了。\n编译manual手册 将下载的软件解压后，进入doc/目录下，运行compile_LaTeX_manual.sh编译manual文档，里边有一部分关于安装的说明。\n1  $ ./compile_LaTeX_manual.sh   安装依赖包 安装依赖包文件需要进入par/目录下运行make，即可成功安装四个依赖包cseife，stfinv，aff，fourier.并编译整个软件包，这一点与根目录下的INSTALL文件不同，原INSTALL文件中说的compileLIBRARIES.sh在par/目录下根本不存在，因此整个编译过程应参考manual文档\n编译 由于源码含F77代码，需要指定F77的编译器，在contrib/下的Makefile_var文件中指定。可根据自己系统的f77编译器确定。笔者使用的gfortran.\n1 2  # edit /DENISE-Release/contrib/Makefile_var FC=/usr/local/gfortran   修改完成之后，回到par/目下执行make即可编译整个程序\n1  $ make   ","permalink":"https://blog.nickwhyy.top/post/denise/","tags":["DENISE"],"title":"Linux 下安装 DENISE"},{"categories":null,"contents":"","permalink":"https://blog.nickwhyy.top/search/","tags":null,"title":"搜索本站内容"}]